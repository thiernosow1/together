#!/usr/bin/env node
"use strict";

var _child_process = require("child_process");

var _util = require("util");

var _yargs = _interopRequireDefault(require("yargs"));

var _server = _interopRequireDefault(require("../server"));

var _installer = _interopRequireDefault(require("../server/installer"));

var _configStore = _interopRequireDefault(require("../lib/config-store"));

var _logger = _interopRequireDefault(require("../lib/logger"));

var _pick = _interopRequireDefault(require("../lib/helpers/pick"));

var _helpers = require("../lib/helpers");

var _helpers2 = require("./helpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const C = new _configStore.default();

function commonOptionsBuilder(program) {
  return program.positional('entry', {
    describe: 'Install entrypoint',
    type: 'string',
    defaultDescription: C.defaults.entry
  }).option('define', {
    alias: 'd',
    describe: 'Variable definitions to be evaluated at install',
    type: 'array',
    default: []
  }).option('ext', {
    alias: 'e',
    describe: 'Extensions to resolve',
    type: 'array',
    defaultDescription: C.defaults.extensions
  }).option('force', {
    alias: 'f',
    describe: 'Skip cache and install directly from source',
    type: 'boolean',
    default: false
  }).option('include', {
    alias: 'i',
    describe: 'Include pattern',
    type: 'array',
    defaultDescription: C.defaults.include
  }).option('mainfields', {
    describe: 'Package entrypoints',
    type: 'array',
    defaultDescription: C.defaults.mainFields
  }).option('moduledirs', {
    describe: 'Module directories',
    type: 'array',
    defaultDescription: C.defaults.moduleDirs
  }).option('output', {
    alias: 'o',
    describe: 'Output directory',
    type: 'string',
    defaultDescription: C.defaults.output
  }).option('root', {
    alias: 'r',
    describe: 'Project root',
    type: 'string',
    defaultDescription: C.defaults.root
  }).option('strict', {
    describe: 'Fail on missing dependency',
    type: 'boolean',
    default: undefined,
    defaultDescription: C.defaults.strict
  }).option('target', {
    describe: 'Output target',
    type: 'string',
    defaultDescription: C.defaults.outputTarget
  }).option('uglify', {
    describe: 'Uglify output',
    type: 'boolean',
    default: undefined,
    defaultDescription: C.defaults.uglify
  }).option('verbose', {
    alias: 'v',
    describe: 'Verbose logging',
    type: 'boolean',
    default: true
  });
}

function commonOptionsParser(argv, extras = []) {
  const {
    define: _define,
    include,
    config,
    entry,
    ext,
    mainfields,
    moduledirs,
    output,
    preset,
    root,
    scope,
    strict,
    target: outputTarget,
    uglify,
    force,
    verbose
  } = argv,
        other = _objectWithoutProperties(argv, ["define", "include", "config", "entry", "ext", "mainfields", "moduledirs", "output", "preset", "root", "scope", "strict", "target", "uglify", "force", "verbose"]);

  if (verbose) {
    _logger.default.level('trace');
  }

  const define = (0, _helpers2.normalizeArrayOption)(_define).reduce((acc, pair) => {
    const [key, value] = pair.split('=');
    return _objectSpread({}, acc, {
      [key]: value
    });
  }, {});
  const extensions = (0, _helpers2.normalizeArrayOption)(ext);
  const mainFields = (0, _helpers2.normalizeArrayOption)(mainfields);
  const moduleDirs = (0, _helpers2.normalizeArrayOption)(moduledirs);
  return (0, _helpers.pickDefined)((0, _helpers2.toPrimitive)(_objectSpread({}, (0, _pick.default)(other, extras), {
    config,
    entry,
    define,
    extensions,
    mainFields,
    moduleDirs,
    output,
    outputTarget,
    preset,
    root,
    scope,
    strict,
    uglify,
    force,
    include
  })));
}

_yargs.default.usage('Usage: $0 <command> [options]').help().option('scope', {
  alias: 's',
  describe: 'Config scope',
  type: 'string',
  default: undefined
}).option('config', {
  alias: 'c',
  describe: 'Path to a .modulerc file',
  type: 'string',
  defaultDescription: C.defaults.config
}).option('preset', {
  alias: 'p',
  describe: 'Load target presets',
  type: 'string',
  defaultDescription: C.defaults.preset
}).command({
  command: 'print-config [options]',
  desc: 'Display the assembled config object(s)',
  handler: async argv => {
    const _commonOptionsParser = commonOptionsParser(argv),
          {
      scope
    } = _commonOptionsParser,
          options = _objectWithoutProperties(_commonOptionsParser, ["scope"]);

    C.init(options);
    (scope ? [scope] : C.scopes()).forEach(symbol => {
      _logger.default.info({
        name: _configStore.default.symbolOf(symbol)
      }, `\n${(0, _util.inspect)((0, _helpers.omit)(C.use(symbol), ['scopeKey', 'core']), {
        colors: true,
        depth: null
      })}\n`);
    });
  }
}).command({
  command: 'install [entry] [options]',
  desc: 'Prep the code you want to serve remotely',
  builder: program => commonOptionsBuilder(program).option('workers', {
    describe: 'Run multi-scope installs on worker processes',
    type: 'boolean',
    default: true
  }),
  handler: async argv => {
    const _commonOptionsParser2 = commonOptionsParser(argv, ['workers']),
          {
      force,
      scope,
      workers
    } = _commonOptionsParser2,
          options = _objectWithoutProperties(_commonOptionsParser2, ["force", "scope", "workers"]);

    try {
      C.init(options);

      if (scope || C.scopes().length === 1) {
        const install = new _installer.default(C.use(scope || C.scopes()[0]));
        await install(force);
      } else if (workers) {
        const [, ...args] = [...process.argv];

        if (!/\/dist\//.test(__filename)) {
          args.unshift('-r', '@babel/register');
        }

        await Promise.all(C.scopes().map(symbol => {
          const scopeKey = _configStore.default.symbolOf(symbol);

          const child = (0, _child_process.spawn)('node', [...args, '-s', scopeKey], {
            stdio: 'inherit'
          });
          process.once('exit', code => child.kill(code));
          return new Promise((resolve, reject) => {
            child.once('exit', code => {
              if (code) {
                reject(new Error(`Worker process for scope '${scopeKey}' exited with code ${code}`));
              } else {
                resolve();
              }
            });
          });
        }));
      } else {
        await Promise.all(C.scopes().map(symbol => {
          const install = new _installer.default(C.use(symbol));
          return install(force);
        }));
      }
    } catch (err) {
      _logger.default.error(err); // eslint-disable-next-line no-process-exit


      process.exit(1);
    }
  }
}).command({
  command: 'start [entry] [options]',
  desc: 'Start the server',
  builder: program => commonOptionsBuilder(program).option('production', {
    describe: 'Start in production mode',
    type: 'boolean',
    default: undefined,
    defaultDescription: false
  }).option('watch', {
    describe: 'Watch for changes',
    type: 'boolean',
    default: undefined,
    defaultDescription: false
  }),
  handler: async argv => {
    const _commonOptionsParser3 = commonOptionsParser(argv, ['production', 'watch']),
          {
      force,
      scope,
      production
    } = _commonOptionsParser3,
          options = _objectWithoutProperties(_commonOptionsParser3, ["force", "scope", "production"]);

    try {
      C.init(options);
      const server = new _server.default(scope ? C.use(scope) : C); // FIXME: this is a quick and dirty check to support production builds

      if (!production) {
        await server.install(force);
      }

      await server.listen();
    } catch (err) {
      _logger.default.error(err); // eslint-disable-next-line no-process-exit


      process.exit(1);
    }
  }
}).wrap(Math.min(100, _yargs.default.terminalWidth())).parse();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGkvaW5kZXguanMiXSwibmFtZXMiOlsiQyIsIkNvbmZpZ1N0b3JlIiwiY29tbW9uT3B0aW9uc0J1aWxkZXIiLCJwcm9ncmFtIiwicG9zaXRpb25hbCIsImRlc2NyaWJlIiwidHlwZSIsImRlZmF1bHREZXNjcmlwdGlvbiIsImRlZmF1bHRzIiwiZW50cnkiLCJvcHRpb24iLCJhbGlhcyIsImRlZmF1bHQiLCJleHRlbnNpb25zIiwiaW5jbHVkZSIsIm1haW5GaWVsZHMiLCJtb2R1bGVEaXJzIiwib3V0cHV0Iiwicm9vdCIsInVuZGVmaW5lZCIsInN0cmljdCIsIm91dHB1dFRhcmdldCIsInVnbGlmeSIsImNvbW1vbk9wdGlvbnNQYXJzZXIiLCJhcmd2IiwiZXh0cmFzIiwiZGVmaW5lIiwiX2RlZmluZSIsImNvbmZpZyIsImV4dCIsIm1haW5maWVsZHMiLCJtb2R1bGVkaXJzIiwicHJlc2V0Iiwic2NvcGUiLCJ0YXJnZXQiLCJmb3JjZSIsInZlcmJvc2UiLCJvdGhlciIsImxvZ2dlciIsImxldmVsIiwicmVkdWNlIiwiYWNjIiwicGFpciIsImtleSIsInZhbHVlIiwic3BsaXQiLCJ5YXJncyIsInVzYWdlIiwiaGVscCIsImNvbW1hbmQiLCJkZXNjIiwiaGFuZGxlciIsIm9wdGlvbnMiLCJpbml0Iiwic2NvcGVzIiwiZm9yRWFjaCIsInN5bWJvbCIsImluZm8iLCJuYW1lIiwic3ltYm9sT2YiLCJ1c2UiLCJjb2xvcnMiLCJkZXB0aCIsImJ1aWxkZXIiLCJ3b3JrZXJzIiwibGVuZ3RoIiwiaW5zdGFsbCIsIkluc3RhbGxlciIsImFyZ3MiLCJwcm9jZXNzIiwidGVzdCIsIl9fZmlsZW5hbWUiLCJ1bnNoaWZ0IiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInNjb3BlS2V5IiwiY2hpbGQiLCJzdGRpbyIsIm9uY2UiLCJjb2RlIiwia2lsbCIsInJlc29sdmUiLCJyZWplY3QiLCJFcnJvciIsImVyciIsImVycm9yIiwiZXhpdCIsInByb2R1Y3Rpb24iLCJzZXJ2ZXIiLCJTZXJ2ZXIiLCJsaXN0ZW4iLCJ3cmFwIiwiTWF0aCIsIm1pbiIsInRlcm1pbmFsV2lkdGgiLCJwYXJzZSJdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUVBOztBQUNBOztBQUVBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQSxNQUFNQSxDQUFDLEdBQUcsSUFBSUMsb0JBQUosRUFBVjs7QUFFQSxTQUFTQyxvQkFBVCxDQUE4QkMsT0FBOUIsRUFBdUM7QUFDdEMsU0FBT0EsT0FBTyxDQUNaQyxVQURLLENBQ00sT0FETixFQUNlO0FBQ3BCQyxJQUFBQSxRQUFRLEVBQUUsb0JBRFU7QUFFcEJDLElBQUFBLElBQUksRUFBRSxRQUZjO0FBR3BCQyxJQUFBQSxrQkFBa0IsRUFBRVAsQ0FBQyxDQUFDUSxRQUFGLENBQVdDO0FBSFgsR0FEZixFQU1MQyxNQU5LLENBTUUsUUFORixFQU1ZO0FBQ2pCQyxJQUFBQSxLQUFLLEVBQUUsR0FEVTtBQUVqQk4sSUFBQUEsUUFBUSxFQUFFLGlEQUZPO0FBR2pCQyxJQUFBQSxJQUFJLEVBQUUsT0FIVztBQUlqQk0sSUFBQUEsT0FBTyxFQUFFO0FBSlEsR0FOWixFQVlMRixNQVpLLENBWUUsS0FaRixFQVlTO0FBQ2RDLElBQUFBLEtBQUssRUFBRSxHQURPO0FBRWROLElBQUFBLFFBQVEsRUFBRSx1QkFGSTtBQUdkQyxJQUFBQSxJQUFJLEVBQUUsT0FIUTtBQUlkQyxJQUFBQSxrQkFBa0IsRUFBRVAsQ0FBQyxDQUFDUSxRQUFGLENBQVdLO0FBSmpCLEdBWlQsRUFrQkxILE1BbEJLLENBa0JFLE9BbEJGLEVBa0JXO0FBQ2hCQyxJQUFBQSxLQUFLLEVBQUUsR0FEUztBQUVoQk4sSUFBQUEsUUFBUSxFQUFFLDZDQUZNO0FBR2hCQyxJQUFBQSxJQUFJLEVBQUUsU0FIVTtBQUloQk0sSUFBQUEsT0FBTyxFQUFFO0FBSk8sR0FsQlgsRUF3QkxGLE1BeEJLLENBd0JFLFNBeEJGLEVBd0JhO0FBQ2xCQyxJQUFBQSxL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QWdCdUQsTUFBQUE7QUFBaEIsS0FBTjtBQUFBLFVBQXFDcEMsT0FBckM7O0FBSUEsUUFBSTtBQUNIcEQsTUFBQUEsQ0FBQyxDQUFDcUQsSUFBRixDQUFPRCxPQUFQO0FBQ0EsWUFBTXFDLE1BQU0sR0FBRyxJQUFJQyxlQUFKLENBQVd6RCxLQUFLLEdBQUdqQyxDQUFDLENBQUM0RCxHQUFGLENBQU0zQixLQUFOLENBQUgsR0FBa0JqQyxDQUFsQyxDQUFmLENBRkcsQ0FHSDs7QUFDQSxVQUFJLENBQUN3RixVQUFMLEVBQWlCO0FBQ2hCLGNBQU1DLE1BQU0sQ0FBQ3ZCLE9BQVAsQ0FBZS9CLEtBQWYsQ0FBTjtBQUNBOztBQUNELFlBQU1zRCxNQUFNLENBQUNFLE1BQVAsRUFBTjtBQUNBLEtBUkQsQ0FRRSxPQUFPTixHQUFQLEVBQVk7QUFDYi9DLHNCQUFPZ0QsS0FBUCxDQUFhRCxHQUFiLEVBRGEsQ0FFYjs7O0FBQ0FoQixNQUFBQSxPQUFPLENBQUNrQixJQUFSLENBQWEsQ0FBYjtBQUNBO0FBQ0Q7QUFuQ08sQ0F6RlYsRUE4SEVLLElBOUhGLENBOEhPQyxJQUFJLENBQUNDLEdBQUwsQ0FBUyxHQUFULEVBQWNoRCxlQUFNaUQsYUFBTixFQUFkLENBOUhQLEVBK0hFQyxLQS9IRiIsInNvdXJjZXNDb250ZW50IjpbIiMhL3Vzci9iaW4vZW52IG5vZGVcblxuaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IGluc3BlY3QgfSBmcm9tICd1dGlsJztcblxuaW1wb3J0IHlhcmdzIGZyb20gJ3lhcmdzJztcblxuaW1wb3J0IFNlcnZlciBmcm9tICcuLi9zZXJ2ZXInO1xuaW1wb3J0IEluc3RhbGxlciBmcm9tICcuLi9zZXJ2ZXIvaW5zdGFsbGVyJztcbmltcG9ydCBDb25maWdTdG9yZSBmcm9tICcuLi9saWIvY29uZmlnLXN0b3JlJztcbmltcG9ydCBsb2dnZXIgZnJvbSAnLi4vbGliL2xvZ2dlcic7XG5pbXBvcnQgcGljayBmcm9tICcuLi9saWIvaGVscGVycy9waWNrJztcbmltcG9ydCB7IG9taXQsIHBpY2tEZWZpbmVkIH0gZnJvbSAnLi4vbGliL2hlbHBlcnMnO1xuaW1wb3J0IHsgbm9ybWFsaXplQXJyYXlPcHRpb24sIHRvUHJpbWl0aXZlIH0gZnJvbSAnLi9oZWxwZXJzJztcblxuY29uc3QgQyA9IG5ldyBDb25maWdTdG9yZSgpO1xuXG5mdW5jdGlvbiBjb21tb25PcHRpb25zQnVpbGRlcihwcm9ncmFtKSB7XG5cdHJldHVybiBwcm9ncmFtXG5cdFx0LnBvc2l0aW9uYWwoJ2VudHJ5Jywge1xuXHRcdFx0ZGVzY3JpYmU6ICdJbnN0YWxsIGVudHJ5cG9pbnQnLFxuXHRcdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0XHRkZWZhdWx0RGVzY3JpcHRpb246IEMuZGVmYXVsdHMuZW50cnlcblx0XHR9KVxuXHRcdC5vcHRpb24oJ2RlZmluZScsIHtcblx0XHRcdGFsaWFzOiAnZCcsXG5cdFx0XHRkZXNjcmliZTogJ1ZhcmlhYmxlIGRlZmluaXRpb25zIHRvIGJlIGV2YWx1YXRlZCBhdCBpbnN0YWxsJyxcblx0XHRcdHR5cGU6ICdhcnJheScsXG5cdFx0XHRkZWZhdWx0OiBbXVxuXHRcdH0pXG5cdFx0Lm9wdGlvbignZXh0Jywge1xuXHRcdFx0YWxpYXM6ICdlJyxcblx0XHRcdGRlc2NyaWJlOiAnRXh0ZW5zaW9ucyB0byByZXNvbHZlJyxcblx0XHRcdHR5cGU6ICdhcnJheScsXG5cdFx0XHRkZWZhdWx0RGVzY3JpcHRpb246IEMuZGVmYXVsdHMuZXh0ZW5zaW9uc1xuXHRcdH0pXG5cdFx0Lm9wdGlvbignZm9yY2UnLCB7XG5cdFx0XHRhbGlhczogJ2YnLFxuXHRcdFx0ZGVzY3JpYmU6ICdTa2lwIGNhY2hlIGFuZCBpbnN0YWxsIGRpcmVjdGx5IGZyb20gc291cmNlJyxcblx0XHRcdHR5cGU6ICdib29sZWFuJyxcblx0XHRcdGRlZmF1bHQ6IGZhbHNlXG5cdFx0fSlcblx0XHQub3B0aW9uKCdpbmNsdWRlJywge1xuXHRcdFx0YWxpYXM6ICdpJyxcblx0XHRcdGRlc2NyaWJlOiAnSW5jbHVkZSBwYXR0ZXJuJyxcblx0XHRcdHR5cGU6ICdhcnJheScsXG5cdFx0XHRkZWZhdWx0RGVzY3JpcHRpb246IEMuZGVmYXVsdHMuaW5jbHVkZVxuXHRcdH0pXG5cdFx0Lm9wdGlvbignbWFpbmZpZWxkcycsIHtcblx0XHRcdGRlc2NyaWJlOiAnUGFja2FnZSBlbnRyeXBvaW50cycsXG5cdFx0XHR0eXBlOiAnYXJyYXknLFxuXHRcdFx0ZGVmYXVsdERlc2NyaXB0aW9uOiBDLmRlZmF1bHRzLm1haW5GaWVsZHNcblx0XHR9KVxuXHRcdC5vcHRpb24oJ21vZHVsZWRpcnMnLCB7XG5cdFx0XHRkZXNjcmliZTogJ01vZHVsZSBkaXJlY3RvcmllcycsXG5cdFx0XHR0eXBlOiAnYXJyYXknLFxuXHRcdFx0ZGVmYXVsdERlc2NyaXB0aW9uOiBDLmRlZmF1bHRzLm1vZHVsZURpcnNcblx0XHR9KVxuXHRcdC5vcHRpb24oJ291dHB1dCcsIHtcblx0XHRcdGFsaWFzOiAnbycsXG5cdFx0XHRkZXNjcmliZTogJ091dHB1dCBkaXJlY3RvcnknLFxuXHRcdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0XHRkZWZhdWx0RGVzY3JpcHRpb246IEMuZGVmYXVsdHMub3V0cHV0XG5cdFx0fSlcblx0XHQub3B0aW9uKCdyb290Jywge1xuXHRcdFx0YWxpYXM6ICdyJyxcblx0XHRcdGRlc2NyaWJlOiAnUHJvamVjdCByb290Jyxcblx0XHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdFx0ZGVmYXVsdERlc2NyaXB0aW9uOiBDLmRlZmF1bHRzLnJvb3Rcblx0XHR9KVxuXHRcdC5vcHRpb24oJ3N0cmljdCcsIHtcblx0XHRcdGRlc2NyaWJlOiAnRmFpbCBvbiBtaXNzaW5nIGRlcGVuZGVuY3knLFxuXHRcdFx0dHlwZTogJ2Jvb2xlYW4nLFxuXHRcdFx0ZGVmYXVsdDogdW5kZWZpbmVkLFxuXHRcdFx0ZGVmYXVsdERlc2NyaXB0aW9uOiBDLmRlZmF1bHRzLnN0cmljdFxuXHRcdH0pXG5cdFx0Lm9wdGlvbigndGFyZ2V0Jywge1xuXHRcdFx0ZGVzY3JpYmU6ICdPdXRwdXQgdGFyZ2V0Jyxcblx0XHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdFx0ZGVmYXVsdERlc2NyaXB0aW9uOiBDLmRlZmF1bHRzLm91dHB1dFRhcmdldFxuXHRcdH0pXG5cdFx0Lm9wdGlvbigndWdsaWZ5Jywge1xuXHRcdFx0ZGVzY3JpYmU6ICdVZ2xpZnkgb3V0cHV0Jyxcblx0XHRcdHR5cGU6ICdib29sZWFuJyxcblx0XHRcdGRlZmF1bHQ6IHVuZGVmaW5lZCxcblx0XHRcdGRlZmF1bHREZXNjcmlwdGlvbjogQy5kZWZhdWx0cy51Z2xpZnlcblx0XHR9KVxuXHRcdC5vcHRpb24oJ3ZlcmJvc2UnLCB7XG5cdFx0XHRhbGlhczogJ3YnLFxuXHRcdFx0ZGVzY3JpYmU6ICdWZXJib3NlIGxvZ2dpbmcnLFxuXHRcdFx0dHlwZTogJ2Jvb2xlYW4nLFxuXHRcdFx0ZGVmYXVsdDogdHJ1ZVxuXHRcdH0pO1xufVxuXG5mdW5jdGlvbiBjb21tb25PcHRpb25zUGFyc2VyKGFyZ3YsIGV4dHJhcyA9IFtdKSB7XG5cdGNvbnN0IHtcblx0XHRkZWZpbmU6IF9kZWZpbmUsXG5cdFx0aW5jbHVkZSxcblx0XHRjb25maWcsXG5cdFx0ZW50cnksXG5cdFx0ZXh0LFxuXHRcdG1haW5maWVsZHMsXG5cdFx0bW9kdWxlZGlycyxcblx0XHRvdXRwdXQsXG5cdFx0cHJlc2V0LFxuXHRcdHJvb3QsXG5cdFx0c2NvcGUsXG5cdFx0c3RyaWN0LFxuXHRcdHRhcmdldDogb3V0cHV0VGFyZ2V0LFxuXHRcdHVnbGlmeSxcblx0XHRmb3JjZSxcblx0XHR2ZXJib3NlLFxuXHRcdC4uLm90aGVyXG5cdH0gPSBhcmd2O1xuXG5cdGlmICh2ZXJib3NlKSB7XG5cdFx0bG9nZ2VyLmxldmVsKCd0cmFjZScpO1xuXHR9XG5cblx0Y29uc3QgZGVmaW5lID0gbm9ybWFsaXplQXJyYXlPcHRpb24oX2RlZmluZSkucmVkdWNlKChhY2MsIHBhaXIpID0+IHtcblx0XHRjb25zdCBba2V5LCB2YWx1ZV0gPSBwYWlyLnNwbGl0KCc9Jyk7XG5cdFx0cmV0dXJuIHsgLi4uYWNjLCBba2V5XTogdmFsdWUgfTtcblx0fSwge30pO1xuXHRjb25zdCBleHRlbnNpb25zID0gbm9ybWFsaXplQXJyYXlPcHRpb24oZXh0KTtcblx0Y29uc3QgbWFpbkZpZWxkcyA9IG5vcm1hbGl6ZUFycmF5T3B0aW9uKG1haW5maWVsZHMpO1xuXHRjb25zdCBtb2R1bGVEaXJzID0gbm9ybWFsaXplQXJyYXlPcHRpb24obW9kdWxlZGlycyk7XG5cblx0cmV0dXJuIHBpY2tEZWZpbmVkKFxuXHRcdHRvUHJpbWl0aXZlKHtcblx0XHRcdC4uLnBpY2sob3RoZXIsIGV4dHJhcyksXG5cdFx0XHRjb25maWcsXG5cdFx0XHRlbnRyeSxcblx0XHRcdGRlZmluZSxcblx0XHRcdGV4dGVuc2lvbnMsXG5cdFx0XHRtYWluRmllbGRzLFxuXHRcdFx0bW9kdWxlRGlycyxcblx0XHRcdG91dHB1dCxcblx0XHRcdG91dHB1dFRhcmdldCxcblx0XHRcdHByZXNldCxcblx0XHRcdHJvb3QsXG5cdFx0XHRzY29wZSxcblx0XHRcdHN0cmljdCxcblx0XHRcdHVnbGlmeSxcblx0XHRcdGZvcmNlLFxuXHRcdFx0aW5jbHVkZVxuXHRcdH0pXG5cdCk7XG59XG5cbnlhcmdzXG5cdC51c2FnZSgnVXNhZ2U6ICQwIDxjb21tYW5kPiBbb3B0aW9uc10nKVxuXHQuaGVscCgpXG5cdC5vcHRpb24oJ3Njb3BlJywge1xuXHRcdGFsaWFzOiAncycsXG5cdFx0ZGVzY3JpYmU6ICdDb25maWcgc2NvcGUnLFxuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHQ6IHVuZGVmaW5lZFxuXHR9KVxuXHQub3B0aW9uKCdjb25maWcnLCB7XG5cdFx0YWxpYXM6ICdjJyxcblx0XHRkZXNjcmliZTogJ1BhdGggdG8gYSAubW9kdWxlcmMgZmlsZScsXG5cdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0ZGVmYXVsdERlc2NyaXB0aW9uOiBDLmRlZmF1bHRzLmNvbmZpZ1xuXHR9KVxuXHQub3B0aW9uKCdwcmVzZXQnLCB7XG5cdFx0YWxpYXM6ICdwJyxcblx0XHRkZXNjcmliZTogJ0xvYWQgdGFyZ2V0IHByZXNldHMnLFxuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHREZXNjcmlwdGlvbjogQy5kZWZhdWx0cy5wcmVzZXRcblx0fSlcblx0LmNvbW1hbmQoe1xuXHRcdGNvbW1hbmQ6ICdwcmludC1jb25maWcgW29wdGlvbnNdJyxcblx0XHRkZXNjOiAnRGlzcGxheSB0aGUgYXNzZW1ibGVkIGNvbmZpZyBvYmplY3QocyknLFxuXHRcdGhhbmRsZXI6IGFzeW5jIGFyZ3YgPT4ge1xuXHRcdFx0Y29uc3QgeyBzY29wZSwgLi4ub3B0aW9ucyB9ID0gY29tbW9uT3B0aW9uc1BhcnNlcihhcmd2KTtcblx0XHRcdEMuaW5pdChvcHRpb25zKTtcblx0XHRcdChzY29wZSA/IFtzY29wZV0gOiBDLnNjb3BlcygpKS5mb3JFYWNoKHN5bWJvbCA9PiB7XG5cdFx0XHRcdGxvZ2dlci5pbmZvKFxuXHRcdFx0XHRcdHsgbmFtZTogQ29uZmlnU3RvcmUuc3ltYm9sT2Yoc3ltYm9sKSB9LFxuXHRcdFx0XHRcdGBcXG4ke2luc3BlY3Qob21pdChDLnVzZShzeW1ib2wpLCBbJ3Njb3BlS2V5JywgJ2NvcmUnXSksIHsgY29sb3JzOiB0cnVlLCBkZXB0aDogbnVsbCB9KX1cXG5gXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pXG5cdC5jb21tYW5kKHtcblx0XHRjb21tYW5kOiAnaW5zdGFsbCBbZW50cnldIFtvcHRpb25zXScsXG5cdFx0ZGVzYzogJ1ByZXAgdGhlIGNvZGUgeW91IHdhbnQgdG8gc2VydmUgcmVtb3RlbHknLFxuXHRcdGJ1aWxkZXI6IHByb2dyYW0gPT5cblx0XHRcdGNvbW1vbk9wdGlvbnNCdWlsZGVyKHByb2dyYW0pLm9wdGlvbignd29ya2VycycsIHtcblx0XHRcdFx0ZGVzY3JpYmU6ICdSdW4gbXVsdGktc2NvcGUgaW5zdGFsbHMgb24gd29ya2VyIHByb2Nlc3NlcycsXG5cdFx0XHRcdHR5cGU6ICdib29sZWFuJyxcblx0XHRcdFx0ZGVmYXVsdDogdHJ1ZVxuXHRcdFx0fSksXG5cdFx0aGFuZGxlcjogYXN5bmMgYXJndiA9PiB7XG5cdFx0XHRjb25zdCB7IGZvcmNlLCBzY29wZSwgd29ya2VycywgLi4ub3B0aW9ucyB9ID0gY29tbW9uT3B0aW9uc1BhcnNlcihhcmd2LCBbJ3dvcmtlcnMnXSk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRDLmluaXQob3B0aW9ucyk7XG5cdFx0XHRcdGlmIChzY29wZSB8fCBDLnNjb3BlcygpLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdGNvbnN0IGluc3RhbGwgPSBuZXcgSW5zdGFsbGVyKEMudXNlKHNjb3BlIHx8IEMuc2NvcGVzKClbMF0pKTtcblx0XHRcdFx0XHRhd2FpdCBpbnN0YWxsKGZvcmNlKTtcblx0XHRcdFx0fSBlbHNlIGlmICh3b3JrZXJzKSB7XG5cdFx0XHRcdFx0Y29uc3QgWywgLi4uYXJnc10gPSBbLi4ucHJvY2Vzcy5hcmd2XTtcblx0XHRcdFx0XHRpZiAoIS9cXC9kaXN0XFwvLy50ZXN0KF9fZmlsZW5hbWUpKSB7XG5cdFx0XHRcdFx0XHRhcmdzLnVuc2hpZnQoJy1yJywgJ0BiYWJlbC9yZWdpc3RlcicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhd2FpdCBQcm9taXNlLmFsbChcblx0XHRcdFx0XHRcdEMuc2NvcGVzKCkubWFwKHN5bWJvbCA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHNjb3BlS2V5ID0gQ29uZmlnU3RvcmUuc3ltYm9sT2Yoc3ltYm9sKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgY2hpbGQgPSBzcGF3bignbm9kZScsIFsuLi5hcmdzLCAnLXMnLCBzY29wZUtleV0sIHsgc3RkaW86ICdpbmhlcml0JyB9KTtcblx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5vbmNlKCdleGl0JywgY29kZSA9PiBjaGlsZC5raWxsKGNvZGUpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRjaGlsZC5vbmNlKCdleGl0JywgY29kZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoY29kZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZWplY3QoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IEVycm9yKGBXb3JrZXIgcHJvY2VzcyBmb3Igc2NvcGUgJyR7c2NvcGVLZXl9JyBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhd2FpdCBQcm9taXNlLmFsbChcblx0XHRcdFx0XHRcdEMuc2NvcGVzKCkubWFwKHN5bWJvbCA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGluc3RhbGwgPSBuZXcgSW5zdGFsbGVyKEMudXNlKHN5bWJvbCkpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaW5zdGFsbChmb3JjZSk7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoZXJyKTtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZXhpdFxuXHRcdFx0XHRwcm9jZXNzLmV4aXQoMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KVxuXHQuY29tbWFuZCh7XG5cdFx0Y29tbWFuZDogJ3N0YXJ0IFtlbnRyeV0gW29wdGlvbnNdJyxcblx0XHRkZXNjOiAnU3RhcnQgdGhlIHNlcnZlcicsXG5cdFx0YnVpbGRlcjogcHJvZ3JhbSA9PlxuXHRcdFx0Y29tbW9uT3B0aW9uc0J1aWxkZXIocHJvZ3JhbSlcblx0XHRcdFx0Lm9wdGlvbigncHJvZHVjdGlvbicsIHtcblx0XHRcdFx0XHRkZXNjcmliZTogJ1N0YXJ0IGluIHByb2R1Y3Rpb24gbW9kZScsXG5cdFx0XHRcdFx0dHlwZTogJ2Jvb2xlYW4nLFxuXHRcdFx0XHRcdGRlZmF1bHQ6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRkZWZhdWx0RGVzY3JpcHRpb246IGZhbHNlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vcHRpb24oJ3dhdGNoJywge1xuXHRcdFx0XHRcdGRlc2NyaWJlOiAnV2F0Y2ggZm9yIGNoYW5nZXMnLFxuXHRcdFx0XHRcdHR5cGU6ICdib29sZWFuJyxcblx0XHRcdFx0XHRkZWZhdWx0OiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0ZGVmYXVsdERlc2NyaXB0aW9uOiBmYWxzZVxuXHRcdFx0XHR9KSxcblx0XHRoYW5kbGVyOiBhc3luYyBhcmd2ID0+IHtcblx0XHRcdGNvbnN0IHsgZm9yY2UsIHNjb3BlLCBwcm9kdWN0aW9uLCAuLi5vcHRpb25zIH0gPSBjb21tb25PcHRpb25zUGFyc2VyKGFyZ3YsIFtcblx0XHRcdFx0J3Byb2R1Y3Rpb24nLFxuXHRcdFx0XHQnd2F0Y2gnXG5cdFx0XHRdKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdEMuaW5pdChvcHRpb25zKTtcblx0XHRcdFx0Y29uc3Qgc2VydmVyID0gbmV3IFNlcnZlcihzY29wZSA/IEMudXNlKHNjb3BlKSA6IEMpO1xuXHRcdFx0XHQvLyBGSVhNRTogdGhpcyBpcyBhIHF1aWNrIGFuZCBkaXJ0eSBjaGVjayB0byBzdXBwb3J0IHByb2R1Y3Rpb24gYnVpbGRzXG5cdFx0XHRcdGlmICghcHJvZHVjdGlvbikge1xuXHRcdFx0XHRcdGF3YWl0IHNlcnZlci5pbnN0YWxsKGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhd2FpdCBzZXJ2ZXIubGlzdGVuKCk7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKGVycik7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWV4aXRcblx0XHRcdFx0cHJvY2Vzcy5leGl0KDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSlcblx0LndyYXAoTWF0aC5taW4oMTAwLCB5YXJncy50ZXJtaW5hbFdpZHRoKCkpKVxuXHQucGFyc2UoKTtcbiJdfQ==