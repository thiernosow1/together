"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCore = isCore;
exports.diffPaths = diffPaths;
exports.resolveSync = resolveSync;
exports.resolveAsync = resolveAsync;
exports.defaultModuleDirs = exports.defaultMainFields = exports.defaultExtensions = exports.defaultCore = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _resolve = _interopRequireDefault(require("resolve"));

var _asyncify = _interopRequireDefault(require("./helpers/asyncify"));

var _promisify = _interopRequireDefault(require("./helpers/promisify"));

var _noop = _interopRequireDefault(require("./helpers/noop"));

var _fs2 = require("./helpers/fs");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const wrappedAsyncResolver = (0, _promisify.default)(_resolve.default);
const defaultCore = _resolve.default.core;
exports.defaultCore = defaultCore;
const defaultExtensions = Object.freeze(['.js', '.jsx', '.mjs', '.es', '.es6', '.json']);
exports.defaultExtensions = defaultExtensions;
const defaultMainFields = Object.freeze(['module', 'main']);
exports.defaultMainFields = defaultMainFields;
const defaultModuleDirs = Object.freeze(['node_modules']);
exports.defaultModuleDirs = defaultModuleDirs;

function isCore(request) {
  return Boolean(_resolve.default.isCore(request));
}
/**
 * If start !== end, return the intermediate paths spanning [start...end] (inclusive)
 * If start === end, return [start]
 * @param {string} start
 * @param {string} [end = start]
 * @return {string[]}
 */


function diffPaths(start, end = start) {
  const paths = [];

  if (start === end) {
    paths[0] = start;
  } else {
    const relative = _path.default.relative(start, end);

    const diff = _path.default.join(relative && '/', relative);

    const segments = diff.split('/');
    const size = segments.length;

    for (let i = 0; i < size; i += 1) {
      paths[i] = _path.default.join(start, ...segments.slice(0, size - i));
    }
  }

  return paths;
}

function doResolve(resolveFn, args, checkFile) {
  const request = args.shift();
  const options = args.pop() || {};

  const {
    core = defaultCore,
    mainFields = defaultMainFields,
    moduleDirs = defaultModuleDirs,
    rootDir = process.cwd(),
    baseDir = rootDir,
    isFile = checkFile
  } = options,
        otherOpts = _objectWithoutProperties(options, ["core", "mainFields", "moduleDirs", "rootDir", "baseDir", "isFile"]);

  const resolverOpts = _objectSpread({
    extensions: defaultExtensions,
    paths: diffPaths(rootDir, baseDir),
    basedir: baseDir,
    moduleDirectory: moduleDirs,
    preserveSymlinks: false,
    packageFilter: pkg => {
      let result = pkg;

      for (const field of mainFields) {
        if (field && pkg[field]) {
          let main = pkg[field];

          if (pkg.main && typeof main === 'object') {
            const normalizedMain = Object.entries(main).reduce((acc, [key, value]) => _objectSpread({}, acc, {
              [_path.default.normalize(key)]: value
            }), {});
            main = normalizedMain[_path.default.normalize(pkg.main)];
          }

          if (typeof main === 'string') {
            result = _objectSpread({}, pkg, {
              main
            });
            break;
          }
        }
      }

      return result;
    },
    isFile: (file, cb = _noop.default) => {
      const constrainedFile = file.startsWith(rootDir) ? file : null;
      return constrainedFile ? isFile(constrainedFile, cb) : cb(null, false);
    }
  }, otherOpts);

  return core[request] ? request : resolveFn(request, resolverOpts);
}

function resolveSync(...args) {
  return doResolve(_resolve.default.sync, args, file => {
    let result = false;

    try {
      // eslint-disable-next-line no-sync
      result = _fs.default.statSync(file).isFile();
    } catch (err) {
      if (err.code !== 'ENOENT' && err.code !== 'ENOTDIR') {
        throw err;
      }
    }

    return result;
  });
}

function resolveAsync(...args) {
  return doResolve(wrappedAsyncResolver, args, (0, _asyncify.default)(async file => {
    let result = false;

    try {
      const stat = await (0, _fs2.statAsync)(file);
      result = stat.isFile();
    } catch (err) {
      if (err.code !== 'ENOENT' && err.code !== 'ENOTDIR') {
        throw err;
      }
    }

    return result;
  }));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVzb2x2ZXIuanMiXSwibmFtZXMiOlsid3JhcHBlZEFzeW5jUmVzb2x2ZXIiLCJtb2R1bGVSZXNvbHZlciIsImRlZmF1bHRDb3JlIiwiY29yZSIsImRlZmF1bHRFeHRlbnNpb25zIiwiT2JqZWN0IiwiZnJlZXplIiwiZGVmYXVsdE1haW5GaWVsZHMiLCJkZWZhdWx0TW9kdWxlRGlycyIsImlzQ29yZSIsInJlcXVlc3QiLCJCb29sZWFuIiwiZGlmZlBhdGhzIiwic3RhcnQiLCJlbmQiLCJwYXRocyIsInJlbGF0aXZlIiwiUGF0aCIsImRpZmYiLCJqb2luIiwic2VnbWVudHMiLCJzcGxpdCIsInNpemUiLCJsZW5ndGgiLCJpIiwic2xpY2UiLCJkb1Jlc29sdmUiLCJyZXNvbHZlRm4iLCJhcmdzIiwiY2hlY2tGaWxlIiwic2hpZnQiLCJvcHRpb25zIiwicG9wIiwibWFpbkZpZWxkcyIsIm1vZHVsZURpcnMiLCJyb290RGlyIiwicHJvY2VzcyIsImN3ZCIsImJhc2VEaXIiLCJpc0ZpbGUiLCJvdGhlck9wdHMiLCJyZXNvbHZlck9wdHMiLCJleHRlbnNpb25zIiwiYmFzZWRpciIsIm1vZHVsZURpcmVjdG9yeSIsInByZXNlcnZlU3ltbGlua3MiLCJwYWNrYWdlRmlsdGVyIiwicGtnIiwicmVzdWx0IiwiZmllbGQiLCJtYWluIiwibm9ybWFsaXplZE1haW4iLCJlbnRyaWVzIiwicmVkdWNlIiwiYWNjIiwia2V5IiwidmFsdWUiLCJub3JtYWxpemUiLCJmaWxlIiwiY2IiLCJub29wIiwiY29uc3RyYWluZWRGaWxlIiwic3RhcnRzV2l0aCIsInJlc29sdmVTeW5jIiwic3luYyIsImZzIiwic3RhdFN5bmMiLCJlcnIiLCJjb2RlIiwicmVzb2x2ZUFzeW5jIiwic3RhdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUEsTUFBTUEsb0JBQW9CLEdB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cnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IFBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCBtb2R1bGVSZXNvbHZlciBmcm9tICdyZXNvbHZlJztcblxuaW1wb3J0IGFzeW5jaWZ5IGZyb20gJy4vaGVscGVycy9hc3luY2lmeSc7XG5pbXBvcnQgcHJvbWlzaWZ5IGZyb20gJy4vaGVscGVycy9wcm9taXNpZnknO1xuaW1wb3J0IG5vb3AgZnJvbSAnLi9oZWxwZXJzL25vb3AnO1xuaW1wb3J0IHsgc3RhdEFzeW5jIH0gZnJvbSAnLi9oZWxwZXJzL2ZzJztcblxuY29uc3Qgd3JhcHBlZEFzeW5jUmVzb2x2ZXIgPSBwcm9taXNpZnkobW9kdWxlUmVzb2x2ZXIpO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdENvcmUgPSBtb2R1bGVSZXNvbHZlci5jb3JlO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdEV4dGVuc2lvbnMgPSBPYmplY3QuZnJlZXplKFsnLmpzJywgJy5qc3gnLCAnLm1qcycsICcuZXMnLCAnLmVzNicsICcuanNvbiddKTtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRNYWluRmllbGRzID0gT2JqZWN0LmZyZWV6ZShbJ21vZHVsZScsICdtYWluJ10pO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdE1vZHVsZURpcnMgPSBPYmplY3QuZnJlZXplKFsnbm9kZV9tb2R1bGVzJ10pO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDb3JlKHJlcXVlc3QpIHtcblx0cmV0dXJuIEJvb2xlYW4obW9kdWxlUmVzb2x2ZXIuaXNDb3JlKHJlcXVlc3QpKTtcbn1cblxuLyoqXG4gKiBJZiBzdGFydCAhPT0gZW5kLCByZXR1cm4gdGhlIGludGVybWVkaWF0ZSBwYXRocyBzcGFubmluZyBbc3RhcnQuLi5lbmRdIChpbmNsdXNpdmUpXG4gKiBJZiBzdGFydCA9PT0gZW5kLCByZXR1cm4gW3N0YXJ0XVxuICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuZCA9IHN0YXJ0XVxuICogQHJldHVybiB7c3RyaW5nW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmUGF0aHMoc3RhcnQsIGVuZCA9IHN0YXJ0KSB7XG5cdGNvbnN0IHBhdGhzID0gW107XG5cdGlmIChzdGFydCA9PT0gZW5kKSB7XG5cdFx0cGF0aHNbMF0gPSBzdGFydDtcblx0fSBlbHNlIHtcblx0XHRjb25zdCByZWxhdGl2ZSA9IFBhdGgucmVsYXRpdmUoc3RhcnQsIGVuZCk7XG5cdFx0Y29uc3QgZGlmZiA9IFBhdGguam9pbihyZWxhdGl2ZSAmJiAnLycsIHJlbGF0aXZlKTtcblx0XHRjb25zdCBzZWdtZW50cyA9IGRpZmYuc3BsaXQoJy8nKTtcblx0XHRjb25zdCBzaXplID0gc2VnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAxKSB7XG5cdFx0XHRwYXRoc1tpXSA9IFBhdGguam9pbihzdGFydCwgLi4uc2VnbWVudHMuc2xpY2UoMCwgc2l6ZSAtIGkpKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHBhdGhzO1xufVxuXG5mdW5jdGlvbiBkb1Jlc29sdmUocmVzb2x2ZUZuLCBhcmdzLCBjaGVja0ZpbGUpIHtcblx0Y29uc3QgcmVxdWVzdCA9IGFyZ3Muc2hpZnQoKTtcblx0Y29uc3Qgb3B0aW9ucyA9IGFyZ3MucG9wKCkgfHwge307XG5cdGNvbnN0IHtcblx0XHRjb3JlID0gZGVmYXVsdENvcmUsXG5cdFx0bWFpbkZpZWxkcyA9IGRlZmF1bHRNYWluRmllbGRzLFxuXHRcdG1vZHVsZURpcnMgPSBkZWZhdWx0TW9kdWxlRGlycyxcblx0XHRyb290RGlyID0gcHJvY2Vzcy5jd2QoKSxcblx0XHRiYXNlRGlyID0gcm9vdERpcixcblx0XHRpc0ZpbGUgPSBjaGVja0ZpbGUsXG5cdFx0Li4ub3RoZXJPcHRzXG5cdH0gPSBvcHRpb25zO1xuXG5cdGNvbnN0IHJlc29sdmVyT3B0cyA9IHtcblx0XHRleHRlbnNpb25zOiBkZWZhdWx0RXh0ZW5zaW9ucyxcblx0XHRwYXRoczogZGlmZlBhdGhzKHJvb3REaXIsIGJhc2VEaXIpLFxuXHRcdGJhc2VkaXI6IGJhc2VEaXIsXG5cdFx0bW9kdWxlRGlyZWN0b3J5OiBtb2R1bGVEaXJzLFxuXHRcdHByZXNlcnZlU3ltbGlua3M6IGZhbHNlLFxuXHRcdHBhY2thZ2VGaWx0ZXI6IHBrZyA9PiB7XG5cdFx0XHRsZXQgcmVzdWx0ID0gcGtnO1xuXHRcdFx0Zm9yIChjb25zdCBmaWVsZCBvZiBtYWluRmllbGRzKSB7XG5cdFx0XHRcdGlmIChmaWVsZCAmJiBwa2dbZmllbGRdKSB7XG5cdFx0XHRcdFx0bGV0IG1haW4gPSBwa2dbZmllbGRdO1xuXHRcdFx0XHRcdGlmIChwa2cubWFpbiAmJiB0eXBlb2YgbWFpbiA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWRNYWluID0gT2JqZWN0LmVudHJpZXMobWFpbikucmVkdWNlKFxuXHRcdFx0XHRcdFx0XHQoYWNjLCBba2V5LCB2YWx1ZV0pID0+ICh7IC4uLmFjYywgW1BhdGgubm9ybWFsaXplKGtleSldOiB2YWx1ZSB9KSxcblx0XHRcdFx0XHRcdFx0e31cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRtYWluID0gbm9ybWFsaXplZE1haW5bUGF0aC5ub3JtYWxpemUocGtnLm1haW4pXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBtYWluID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0geyAuLi5wa2csIG1haW4gfTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXHRcdGlzRmlsZTogKGZpbGUsIGNiID0gbm9vcCkgPT4ge1xuXHRcdFx0Y29uc3QgY29uc3RyYWluZWRGaWxlID0gZmlsZS5zdGFydHNXaXRoKHJvb3REaXIpID8gZmlsZSA6IG51bGw7XG5cdFx0XHRyZXR1cm4gY29uc3RyYWluZWRGaWxlID8gaXNGaWxlKGNvbnN0cmFpbmVkRmlsZSwgY2IpIDogY2IobnVsbCwgZmFsc2UpO1xuXHRcdH0sXG5cdFx0Li4ub3RoZXJPcHRzXG5cdH07XG5cblx0cmV0dXJuIGNvcmVbcmVxdWVzdF0gPyByZXF1ZXN0IDogcmVzb2x2ZUZuKHJlcXVlc3QsIHJlc29sdmVyT3B0cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlU3luYyguLi5hcmdzKSB7XG5cdHJldHVybiBkb1Jlc29sdmUobW9kdWxlUmVzb2x2ZXIuc3luYywgYXJncywgZmlsZSA9PiB7XG5cdFx0bGV0IHJlc3VsdCA9IGZhbHNlO1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc3luY1xuXHRcdFx0cmVzdWx0ID0gZnMuc3RhdFN5bmMoZmlsZSkuaXNGaWxlKCk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRpZiAoZXJyLmNvZGUgIT09ICdFTk9FTlQnICYmIGVyci5jb2RlICE9PSAnRU5PVERJUicpIHtcblx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVBc3luYyguLi5hcmdzKSB7XG5cdHJldHVybiBkb1Jlc29sdmUoXG5cdFx0d3JhcHBlZEFzeW5jUmVzb2x2ZXIsXG5cdFx0YXJncyxcblx0XHRhc3luY2lmeShhc3luYyBmaWxlID0+IHtcblx0XHRcdGxldCByZXN1bHQgPSBmYWxzZTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHN0YXQgPSBhd2FpdCBzdGF0QXN5bmMoZmlsZSk7XG5cdFx0XHRcdHJlc3VsdCA9IHN0YXQuaXNGaWxlKCk7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0aWYgKGVyci5jb2RlICE9PSAnRU5PRU5UJyAmJiBlcnIuY29kZSAhPT0gJ0VOT1RESVInKSB7XG5cdFx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0pXG5cdCk7XG59XG4iXX0=