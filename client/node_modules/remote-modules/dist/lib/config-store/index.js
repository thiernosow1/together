"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _url = _interopRequireDefault(require("url"));

var _fs = _interopRequireDefault(require("fs"));

var _glob = _interopRequireDefault(require("glob"));

var _nodeLibsBrowser = _interopRequireDefault(require("node-libs-browser"));

var _cloneDeep = _interopRequireDefault(require("clone-deep"));

var _deepmerge = _interopRequireDefault(require("deepmerge"));

var _babelMerge = _interopRequireDefault(require("babel-merge"));

var _resolver = require("../resolver");

var _helpers = require("../helpers");

var _get = _interopRequireDefault(require("../helpers/get"));

var _once = _interopRequireDefault(require("../helpers/once"));

var _pick = _interopRequireDefault(require("../helpers/pick"));

var _defineProperties = _interopRequireDefault(require("../helpers/defineProperties"));

var _calculated = _interopRequireDefault(require("./calculated"));

var _defaults = _interopRequireDefault(require("./defaults"));

var _presets = _interopRequireDefault(require("./presets"));

var middleware = _interopRequireWildcard(require("./middleware"));

var _default = _interopRequireDefault(require("../../server/installer/resource/adapters/default"));

var _json = _interopRequireDefault(require("../../server/installer/resource/adapters/json"));

var _less = _interopRequireDefault(require("../../server/installer/resource/adapters/less"));

var _sass = _interopRequireDefault(require("../../server/installer/resource/adapters/sass"));

var _css = _interopRequireDefault(require("../../server/installer/resource/adapters/css"));

var _raw = _interopRequireDefault(require("../../server/installer/resource/adapters/raw"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ConfigStore {
  static symbolFor(value = ConfigStore.defaultScope) {
    return typeof value === 'symbol' ? value : Symbol.for(`@${value.replace(/^@/, '')}`);
  }

  static symbolOf(value = ConfigStore.defaultScope) {
    return typeof value === 'symbol' ? Symbol.keyFor(value) : value.replace(/^@/, '');
  }

  static from(target = {}) {
    let C;

    if (target instanceof ConfigStore) {
      C = target;
    } else {
      C = new ConfigStore(target);
    }

    return C;
  }

  static getModulerc(path) {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const modulerc = require(path);

    const result = (0, _get.default)(modulerc, ['default']) || modulerc;
    return typeof result === 'function' ? result(_objectSpread({}, middleware, ConfigStore.adapters, {
      Scope: ConfigStore.symbolFor,
      Shim: key => {
        if (!Object.hasOwnProperty.call(ConfigStore.shims, key)) {
          throw new Error(`Missing shim '${key}'`);
        }

        return ConfigStore.shims[key];
      }
    })) : result;
  }

  static loadrcFile(opts) {
    let result = {};

    if (typeof opts.root === 'string' && typeof opts.config === 'string') {
      try {
        const rcpath = (0, _resolver.resolveSync)(opts.config, {
          baseDir: opts.root,
          extensions: ['.js', '.mjs', '.es', '.es6', '.babel.js', '.json']
        });

        if (rcpath) {
          result = Object.assign(ConfigStore.getModulerc(rcpath), {
            rcpath
          });
        }
      } catch (err) {
        if (err.code !== 'MODULE_NOT_FOUND') {
          throw err;
        }
      }
    }

    return result;
  }

  static getEntryDir(rootDir, entry) {
    let result = _path.default.resolve(rootDir, entry);

    try {
      // eslint-disable-next-line no-sync
      const stats = _fs.default.statSync(result);

      if (!stats.isDirectory()) {
        result = _path.default.dirname(result);
      }
    } catch (err) {
      if (err.code !== 'ENOENT') {
        throw err;
      }

      result = ConfigStore.getEntryDir(rootDir, _path.default.dirname(entry));
    }

    return result;
  }

  static getMergedOpts(inputOpts = {}, scopeOpts = {}) {
    const defaults = (0, _defaults.default)();
    const modulerc = ConfigStore.loadrcFile(_objectSpread({}, defaults, inputOpts));
    const presetOpts = (0, _presets.default)(inputOpts.preset || scopeOpts.preset || modulerc.preset);
    const mergeValues = [defaults, presetOpts, modulerc, scopeOpts, inputOpts, (0, _get.default)(modulerc, [scopeOpts.scope]), (0, _get.default)(inputOpts, [scopeOpts.scope])].filter(Boolean);

    const mergedOpts = _deepmerge.default.all(mergeValues.map(obj => (0, _helpers.pickDefined)((0, _helpers.omit)(obj, ['babel']))), {
      arrayMerge: (prev, next) => Array.from(new Set([...Array.from(next || []), ...Array.from(prev || [])])),
      isMergeableObject: value => (0, _helpers.isPlainObject)(value) || Array.isArray(value)
    });

    if (mergedOpts.scope) {
      const scopeKey = ConfigStore.symbolOf(mergedOpts.scope);
      const {
        output,
        server: {
          uri
        }
      } = mergedOpts;

      const _Url$parse = _url.default.parse(uri),
            {
        host,
        protocol
      } = _Url$parse,
            other = _objectWithoutProperties(_Url$parse, ["host", "protocol"]);

      const pathname = _path.default.join(other.pathname, scopeKey);

      Object.assign(mergedOpts, {
        output: _path.default.join(output, scopeKey),
        server: _objectSpread({}, mergedOpts.server, {
          uri: _url.default.format({
            host,
            protocol,
            pathname
          })
        })
      });
    } else {
      let scopes = [...Object.getOwnPropertySymbols(inputOpts), ...Object.getOwnPropertySymbols(modulerc)];

      if (!scopes.length) {
        scopes = [ConfigStore.defaultScope];
      }

      scopes.forEach(scope => {
        mergedOpts[scope] = _objectSpread({}, modulerc[scope], inputOpts[scope], {
          scope
        });
      });
    }

    const root = _path.default.normalize(mergedOpts.root);

    const output = _path.default.normalize(mergedOpts.output);

    const entry = _path.default.normalize(mergedOpts.entry);

    const rootDir = _path.default.resolve(root);

    const outputDir = _path.default.resolve(output);

    const entryDir = ConfigStore.getEntryDir(rootDir, entry);
    Object.assign(mergedOpts, {
      root,
      output,
      entry,
      rootDir,
      outputDir,
      entryDir
    }); // Babel config

    mergedOpts.babel = _babelMerge.default.all(mergeValues.map(({
      babel
    }) => babel)); // include globs

    mergedOpts.include = mergedOpts.include.reduce((acc, include) => {
      if (_glob.default.hasMagic(include)) {
        acc.push(..._glob.default.sync(include, {
          cwd: mergedOpts.rootDir
        }).map(path => _path.default.resolve(mergedOpts.rootDir, path)));
      } else {
        acc.push(include);
      }

      return acc;
    }, []); // server.static globs

    mergedOpts.server.static = new Set(Array.from(mergedOpts.server.static).reduce((acc, pattern) => [...acc, ...(_glob.default.hasMagic(pattern) ? _glob.default.sync(pattern) : [pattern])], [])); // Remove falsy middleware values

    mergedOpts.middleware = mergedOpts.middleware.filter(Boolean); // Calculated properties

    return Object.assign(mergedOpts, (0, _calculated.default)(mergedOpts));
  }

  constructor(opts, configRoot) {
    ConfigStore.getEnv.clear();
    (0, _defineProperties.default)(this, {
      defaults: (0, _defaults.default)(),
      scopeKey: {
        get: () => this.scope && ConfigStore.symbolOf(this.scope),
        set: () => {},
        enumerable: true
      }
    });

    if (opts) {
      if (configRoot && opts.scope) {
        this.initScope(opts, configRoot);
      } else {
        this.init(opts);
      }
    }
  }

  init(opts) {
    Object.assign(this, ConfigStore.getMergedOpts(opts));
    this.scopes().forEach(scope => {
      Object.assign(this[scope], ConfigStore.getMergedOpts(opts, this[scope]));
    });
    return this;
  }

  initScope(opts, configRoot) {
    Object.assign(this, (0, _cloneDeep.default)(opts));
    return (0, _defineProperties.default)(this, {
      configRoot
    });
  }

  scopes() {
    return this.scope ? [this.scope] : Object.getOwnPropertySymbols(this);
  }

  use(_scope = ConfigStore.defaultScope) {
    const scope = ConfigStore.symbolFor(_scope);
    const scopeObject = scope === this.scope ? this : this[scope];

    if (!scopeObject) {
      throw new Error(`Scope '${ConfigStore.symbolOf(scope)}' does not exist`);
    }

    return new ConfigStore(scopeObject, this.getRoot());
  }

  runMiddleware(type, args) {
    for (const _ref of this.middleware.filter(m => m.type === type)) {
      const {
        fn
      } = _ref;
      // eslint-disable-next-line prefer-spread
      fn.apply(null, args);
    }
  }

  getRoot() {
    return this.configRoot || this;
  }

  get(path) {
    return (0, _get.default)(this, path);
  }

  pick(keys) {
    return (0, _pick.default)(this, keys);
  }

}

exports.default = ConfigStore;

_defineProperty(ConfigStore, "getCalculated", _calculated.default);

_defineProperty(ConfigStore, "getDefaults", _defaults.default);

_defineProperty(ConfigStore, "getPreset", _presets.default);

_defineProperty(ConfigStore, "middleware", middleware);

_defineProperty(ConfigStore, "defaultScope", ConfigStore.symbolFor('default'));

_defineProperty(ConfigStore, "getEnv", (0, _once.default)(() => {
  const {
    env: {
      BUILD_ENV,
      NODE_ENV
    }
  } = process;
  return BUILD_ENV || NODE_ENV || 'development';
}));

_defineProperty(ConfigStore, "adapters", {
  ScriptAdapter: _default.default,
  JSONAdapter: _json.default,
  SASSAdapter: _sass.default,
  LESSAdapter: _less.default,
  CSSAdapter: _css.default,
  RawAdapter: _raw.default
});

_defineProperty(ConfigStore, "shims", (0, _helpers.mapObject)(_nodeLibsBrowser.default, path => path ? _path.default.relative(_path.default.resolve('node_modules'), path) : null));

_defineProperty(ConfigStore, "mocks", {
  buffer: 'node-libs-browser/mock/buffer.js'
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvY29uZmlnLXN0b3JlL2luZGV4LmpzIl0sIm5hbWVzIjpbIkNvbmZpZ1N0b3JlIiwic3ltYm9sRm9yIiwidmFsdWUiLCJkZWZhdWx0U2NvcGUiLCJTeW1ib2wiLCJmb3IiLCJyZXBsYWNlIiwic3ltYm9sT2YiLCJrZXlGb3IiLCJmcm9tIiwidGFyZ2V0IiwiQyIsImdldE1vZHVsZXJjIiwicGF0aCIsIm1vZHVsZXJjIiwicmVxdWlyZSIsInJlc3VsdCIsIm1pZGRsZXdhcmUiLCJhZGFwdGVycyIsIlNjb3BlIiwiU2hpbSIsImtleSIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInNoaW1zIiwiRXJyb3IiLCJsb2FkcmNGaWxlIiwib3B0cyIsInJvb3QiLCJjb25maWciLCJyY3BhdGgiLCJiYXNlRGlyIiwiZXh0ZW5zaW9ucyIsImFzc2lnbiIsImVyciIsImNvZGUiLCJnZXRFbnRyeURpciIsInJvb3REaXIiLCJlbnRyeSIsIlBhdGgiLCJyZXNvbHZlIiwic3RhdHMiLCJmcyIsInN0YXRTeW5jIiwiaXNEaXJlY3RvcnkiLCJkaXJuYW1lIiwiZ2V0TWVyZ2VkT3B0cyIsImlucHV0T3B0cyIsInNjb3BlT3B0cyIsImRlZmF1bHRzIiwicHJlc2V0T3B0cyIsInByZXNldCIsIm1lcmdlVmFsdWVzIiwic2NvcGUiLCJmaWx0ZXIiLCJCb29sZWFuIiwibWVyZ2VkT3B0cyIsIm1lcmdlIiwiYWxsIiwibWFwIiwib2JqIiwiYXJyYXlNZXJnZSIsInByZXYiLCJuZXh0IiwiQXJyYXkiLCJTZXQiLCJpc01lcmdlYWJsZU9iamVjdCIsImlzQXJyYXkiLCJzY29wZUtleSIsIm91dHB1dCIsInNlcnZlciIsInVyaSIsIlVybCIsInBhcnNlIiwiaG9zdCIsInByb3RvY29sIiwib3RoZXIiLCJwYXRobmFtZSIsImpvaW4iLCJmb3JtYXQiLCJzY29wZXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwibm9ybWFsaXplIiwib3V0cHV0RGlyIiwiZW50cnlEaXIiLCJiYWJlbCIsImJhYmVsTWVyZ2UiLCJpbmNsdWRlIiwicmVkdWNlIiwiYWNjIiwiZ2xvYiIsImhhc01hZ2ljIiwicHVzaCIsInN5bmMiLCJjd2QiLCJzdGF0aWMiLCJwYXR0ZXJuIiwiY29uc3RydWN0b3IiLCJjb25maWdSb290IiwiZ2V0RW52IiwiY2xlYXIiLCJnZXQiLCJzZXQiLCJlbnVtZXJhYmxlIiwiaW5pdFNjb3BlIiwiaW5pdCIsInVzZSIsIl9zY29wZSIsInNjb3BlT2JqZWN0IiwiZ2V0Um9vdCIsInJ1bk1pZGRsZXdhcmUiLCJ0eXBlIiwiYXJncyIsIm0iLCJmbiIsImFwcGx5IiwicGljayIsImtleXMiLCJnZXRDYWxjdWxhdGVkIiwiZ2V0RGVmYXVsdHMiLCJnZXRQcmVzZXQiLCJlbnYiLCJCVUlMRF9FTlYiLCJOT0RFX0VOViIsInByb2Nlc3MiLCJTY3JpcHRBZGFwdGVyIiwiSlNPTkFkYXB0ZXIiLCJTQVNTQWRhcHRlciIsIkxFU1NBZGFwdGVyIiwiQ1NTQWRhcHRlciIsIlJhd0FkYXB0ZXIiLCJicm93c2VyU2hpbXMiLCJyZWxhdGl2ZSIsImJ1ZmZlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVlLE1BQU1BLFdBQU4sQ0FBa0I7QUFvQ2hDLFNBQU9DLFNBQVAsQ0FBaUJDLEtBQUssR0FBR0YsV0FBVyxDQUFDRyxZQUFyQyxFQUFtRDtBQUNsRCxXQUFPLE9BQU9ELEtBQVAsS0FBaUIsUUFBakIsR0FBNEJBLEtBQTVCLEdBQW9DRSxNQUFNLENBQUNDLEdBQVAsQ0FBWSxJQUFHSCxLQUFLLENBQUNJLE9BQU4sQ0FBYyxJQUFkLEVBQW9CLEVBQXBC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akJnSSxFQUFBQSxhQUFhLEVBQWJBLGdCQURpQjtBQUVqQkMsRUFBQUEsV0FBVyxFQUFYQSxhQUZpQjtBQUdqQkMsRUFBQUEsV0FBVyxFQUFYQSxhQUhpQjtBQUlqQkMsRUFBQUEsV0FBVyxFQUFYQSxhQUppQjtBQUtqQkMsRUFBQUEsVUFBVSxFQUFWQSxZQUxpQjtBQU1qQkMsRUFBQUEsVUFBVSxFQUFWQTtBQU5pQixDOztnQkFsQkVySSxXLFdBMkJMLHdCQUNkc0ksd0JBRGMsRUFFZHpILElBQUksSUFBS0EsSUFBSSxHQUFHMkIsY0FBSytGLFFBQUwsQ0FBYy9GLGNBQUtDLE9BQUwsQ0FBYSxjQUFiLENBQWQsRUFBNEM1QixJQUE1QyxDQUFILEdBQXVELElBRnRELEM7O2dCQTNCS2IsVyxXQWdDTDtBQUNkd0ksRUFBQUEsTUFBTSxFQUFFO0FBRE0sQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IFVybCBmcm9tICd1cmwnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcblxuaW1wb3J0IGdsb2IgZnJvbSAnZ2xvYic7XG5pbXBvcnQgYnJvd3NlclNoaW1zIGZyb20gJ25vZGUtbGlicy1icm93c2VyJztcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnY2xvbmUtZGVlcCc7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcbmltcG9ydCBiYWJlbE1lcmdlIGZyb20gJ2JhYmVsLW1lcmdlJztcblxuaW1wb3J0IHsgcmVzb2x2ZVN5bmMgfSBmcm9tICcuLi9yZXNvbHZlcic7XG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0LCBtYXBPYmplY3QsIG9taXQsIHBpY2tEZWZpbmVkIH0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgZ2V0IGZyb20gJy4uL2hlbHBlcnMvZ2V0JztcbmltcG9ydCBvbmNlIGZyb20gJy4uL2hlbHBlcnMvb25jZSc7XG5pbXBvcnQgcGljayBmcm9tICcuLi9oZWxwZXJzL3BpY2snO1xuaW1wb3J0IGRlZmluZVByb3BlcnRpZXMgZnJvbSAnLi4vaGVscGVycy9kZWZpbmVQcm9wZXJ0aWVzJztcbmltcG9ydCBnZXRDYWxjdWxhdGVkIGZyb20gJy4vY2FsY3VsYXRlZCc7XG5pbXBvcnQgZ2V0RGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0cyc7XG5pbXBvcnQgZ2V0UHJlc2V0IGZyb20gJy4vcHJlc2V0cyc7XG5pbXBvcnQgKiBhcyBtaWRkbGV3YXJlIGZyb20gJy4vbWlkZGxld2FyZSc7XG5cbmltcG9ydCBTY3JpcHRBZGFwdGVyIGZyb20gJy4uLy4uL3NlcnZlci9pbnN0YWxsZXIvcmVzb3VyY2UvYWRhcHRlcnMvZGVmYXVsdCc7XG5pbXBvcnQgSlNPTkFkYXB0ZXIgZnJvbSAnLi4vLi4vc2VydmVyL2luc3RhbGxlci9yZXNvdXJjZS9hZGFwdGVycy9qc29uJztcbmltcG9ydCBMRVNTQWRhcHRlciBmcm9tICcuLi8uLi9zZXJ2ZXIvaW5zdGFsbGVyL3Jlc291cmNlL2FkYXB0ZXJzL2xlc3MnO1xuaW1wb3J0IFNBU1NBZGFwdGVyIGZyb20gJy4uLy4uL3NlcnZlci9pbnN0YWxsZXIvcmVzb3VyY2UvYWRhcHRlcnMvc2Fzcyc7XG5pbXBvcnQgQ1NTQWRhcHRlciBmcm9tICcuLi8uLi9zZXJ2ZXIvaW5zdGFsbGVyL3Jlc291cmNlL2FkYXB0ZXJzL2Nzcyc7XG5pbXBvcnQgUmF3QWRhcHRlciBmcm9tICcuLi8uLi9zZXJ2ZXIvaW5zdGFsbGVyL3Jlc291cmNlL2FkYXB0ZXJzL3Jhdyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbmZpZ1N0b3JlIHtcblx0c3RhdGljIGdldENhbGN1bGF0ZWQgPSBnZXRDYWxjdWxhdGVkO1xuXG5cdHN0YXRpYyBnZXREZWZhdWx0cyA9IGdldERlZmF1bHRzO1xuXG5cdHN0YXRpYyBnZXRQcmVzZXQgPSBnZXRQcmVzZXQ7XG5cblx0c3RhdGljIG1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlO1xuXG5cdHN0YXRpYyBkZWZhdWx0U2NvcGUgPSBDb25maWdTdG9yZS5zeW1ib2xGb3IoJ2RlZmF1bHQnKTtcblxuXHRzdGF0aWMgZ2V0RW52ID0gb25jZSgoKSA9PiB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZW52OiB7IEJVSUxEX0VOViwgTk9ERV9FTlYgfVxuXHRcdH0gPSBwcm9jZXNzO1xuXHRcdHJldHVybiBCVUlMRF9FTlYgfHwgTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50Jztcblx0fSk7XG5cblx0c3RhdGljIGFkYXB0ZXJzID0ge1xuXHRcdFNjcmlwdEFkYXB0ZXIsXG5cdFx0SlNPTkFkYXB0ZXIsXG5cdFx0U0FTU0FkYXB0ZXIsXG5cdFx0TEVTU0FkYXB0ZXIsXG5cdFx0Q1NTQWRhcHRlcixcblx0XHRSYXdBZGFwdGVyXG5cdH07XG5cblx0c3RhdGljIHNoaW1zID0gbWFwT2JqZWN0KFxuXHRcdGJyb3dzZXJTaGltcyxcblx0XHRwYXRoID0+IChwYXRoID8gUGF0aC5yZWxhdGl2ZShQYXRoLnJlc29sdmUoJ25vZGVfbW9kdWxlcycpLCBwYXRoKSA6IG51bGwpXG5cdCk7XG5cblx0c3RhdGljIG1vY2tzID0ge1xuXHRcdGJ1ZmZlcjogJ25vZGUtbGlicy1icm93c2VyL21vY2svYnVmZmVyLmpzJ1xuXHR9O1xuXG5cdHN0YXRpYyBzeW1ib2xGb3IodmFsdWUgPSBDb25maWdTdG9yZS5kZWZhdWx0U2NvcGUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyA/IHZhbHVlIDogU3ltYm9sLmZvcihgQCR7dmFsdWUucmVwbGFjZSgvXkAvLCAnJyl9YCk7XG5cdH1cblxuXHRzdGF0aWMgc3ltYm9sT2YodmFsdWUgPSBDb25maWdTdG9yZS5kZWZhdWx0U2NvcGUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyA/IFN5bWJvbC5rZXlGb3IodmFsdWUpIDogdmFsdWUucmVwbGFjZSgvXkAvLCAnJyk7XG5cdH1cblxuXHRzdGF0aWMgZnJvbSh0YXJnZXQgPSB7fSkge1xuXHRcdGxldCBDO1xuXHRcdGlmICh0YXJnZXQgaW5zdGFuY2VvZiBDb25maWdTdG9yZSkge1xuXHRcdFx0QyA9IHRhcmdldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QyA9IG5ldyBDb25maWdTdG9yZSh0YXJnZXQpO1xuXHRcdH1cblx0XHRyZXR1cm4gQztcblx0fVxuXG5cdHN0YXRpYyBnZXRNb2R1bGVyYyhwYXRoKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlLCBpbXBvcnQvbm8tZHluYW1pYy1yZXF1aXJlXG5cdFx0Y29uc3QgbW9kdWxlcmMgPSByZXF1aXJlKHBhdGgpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IGdldChtb2R1bGVyYywgWydkZWZhdWx0J10pIHx8IG1vZHVsZXJjO1xuXHRcdHJldHVybiB0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nXG5cdFx0XHQ/IHJlc3VsdCh7XG5cdFx0XHRcdFx0Li4ubWlkZGxld2FyZSxcblx0XHRcdFx0XHQuLi5Db25maWdTdG9yZS5hZGFwdGVycyxcblx0XHRcdFx0XHRTY29wZTogQ29uZmlnU3RvcmUuc3ltYm9sRm9yLFxuXHRcdFx0XHRcdFNoaW06IGtleSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKENvbmZpZ1N0b3JlLnNoaW1zLCBrZXkpKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBzaGltICcke2tleX0nYCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gQ29uZmlnU3RvcmUuc2hpbXNba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHQgIH0pXG5cdFx0XHQ6IHJlc3VsdDtcblx0fVxuXG5cdHN0YXRpYyBsb2FkcmNGaWxlKG9wdHMpIHtcblx0XHRsZXQgcmVzdWx0ID0ge307XG5cdFx0aWYgKHR5cGVvZiBvcHRzLnJvb3QgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBvcHRzLmNvbmZpZyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHJjcGF0aCA9IHJlc29sdmVTeW5jKG9wdHMuY29uZmlnLCB7XG5cdFx0XHRcdFx0YmFzZURpcjogb3B0cy5yb290LFxuXHRcdFx0XHRcdGV4dGVuc2lvbnM6IFsnLmpzJywgJy5tanMnLCAnLmVzJywgJy5lczYnLCAnLmJhYmVsLmpzJywgJy5qc29uJ11cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChyY3BhdGgpIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBPYmplY3QuYXNzaWduKENvbmZpZ1N0b3JlLmdldE1vZHVsZXJjKHJjcGF0aCksIHsgcmNwYXRoIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0aWYgKGVyci5jb2RlICE9PSAnTU9EVUxFX05PVF9GT1VORCcpIHtcblx0XHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdHN0YXRpYyBnZXRFbnRyeURpcihyb290RGlyLCBlbnRyeSkge1xuXHRcdGxldCByZXN1bHQgPSBQYXRoLnJlc29sdmUocm9vdERpciwgZW50cnkpO1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc3luY1xuXHRcdFx0Y29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhyZXN1bHQpO1xuXHRcdFx0aWYgKCFzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG5cdFx0XHRcdHJlc3VsdCA9IFBhdGguZGlybmFtZShyZXN1bHQpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0aWYgKGVyci5jb2RlICE9PSAnRU5PRU5UJykge1xuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSBDb25maWdTdG9yZS5nZXRFbnRyeURpcihyb290RGlyLCBQYXRoLmRpcm5hbWUoZW50cnkpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdHN0YXRpYyBnZXRNZXJnZWRPcHRzKGlucHV0T3B0cyA9IHt9LCBzY29wZU9wdHMgPSB7fSkge1xuXHRcdGNvbnN0IGRlZmF1bHRzID0gZ2V0RGVmYXVsdHMoKTtcblx0XHRjb25zdCBtb2R1bGVyYyA9IENvbmZpZ1N0b3JlLmxvYWRyY0ZpbGUoeyAuLi5kZWZhdWx0cywgLi4uaW5wdXRPcHRzIH0pO1xuXHRcdGNvbnN0IHByZXNldE9wdHMgPSBnZXRQcmVzZXQoaW5wdXRPcHRzLnByZXNldCB8fCBzY29wZU9wdHMucHJlc2V0IHx8IG1vZHVsZXJjLnByZXNldCk7XG5cdFx0Y29uc3QgbWVyZ2VWYWx1ZXMgPSBbXG5cdFx0XHRkZWZhdWx0cyxcblx0XHRcdHByZXNldE9wdHMsXG5cdFx0XHRtb2R1bGVyYyxcblx0XHRcdHNjb3BlT3B0cyxcblx0XHRcdGlucHV0T3B0cyxcblx0XHRcdGdldChtb2R1bGVyYywgW3Njb3BlT3B0cy5zY29wZV0pLFxuXHRcdFx0Z2V0KGlucHV0T3B0cywgW3Njb3BlT3B0cy5zY29wZV0pXG5cdFx0XS5maWx0ZXIoQm9vbGVhbik7XG5cblx0XHRjb25zdCBtZXJnZWRPcHRzID0gbWVyZ2UuYWxsKG1lcmdlVmFsdWVzLm1hcChvYmogPT4gcGlja0RlZmluZWQob21pdChvYmosIFsnYmFiZWwnXSkpKSwge1xuXHRcdFx0YXJyYXlNZXJnZTogKHByZXYsIG5leHQpID0+XG5cdFx0XHRcdEFycmF5LmZyb20obmV3IFNldChbLi4uQXJyYXkuZnJvbShuZXh0IHx8IFtdKSwgLi4uQXJyYXkuZnJvbShwcmV2IHx8IFtdKV0pKSxcblx0XHRcdGlzTWVyZ2VhYmxlT2JqZWN0OiB2YWx1ZSA9PiBpc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKVxuXHRcdH0pO1xuXG5cdFx0aWYgKG1lcmdlZE9wdHMuc2NvcGUpIHtcblx0XHRcdGNvbnN0IHNjb3BlS2V5ID0gQ29uZmlnU3RvcmUuc3ltYm9sT2YobWVyZ2VkT3B0cy5zY29wZSk7XG5cdFx0XHRjb25zdCB7XG5cdFx0XHRcdG91dHB1dCxcblx0XHRcdFx0c2VydmVyOiB7IHVyaSB9XG5cdFx0XHR9ID0gbWVyZ2VkT3B0cztcblx0XHRcdGNvbnN0IHsgaG9zdCwgcHJvdG9jb2wsIC4uLm90aGVyIH0gPSBVcmwucGFyc2UodXJpKTtcblx0XHRcdGNvbnN0IHBhdGhuYW1lID0gUGF0aC5qb2luKG90aGVyLnBhdGhuYW1lLCBzY29wZUtleSk7XG5cdFx0XHRPYmplY3QuYXNzaWduKG1lcmdlZE9wdHMsIHtcblx0XHRcdFx0b3V0cHV0OiBQYXRoLmpvaW4ob3V0cHV0LCBzY29wZUtleSksXG5cdFx0XHRcdHNlcnZlcjoge1xuXHRcdFx0XHRcdC4uLm1lcmdlZE9wdHMuc2VydmVyLFxuXHRcdFx0XHRcdHVyaTogVXJsLmZvcm1hdCh7IGhvc3QsIHByb3RvY29sLCBwYXRobmFtZSB9KVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IHNjb3BlcyA9IFtcblx0XHRcdFx0Li4uT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhpbnB1dE9wdHMpLFxuXHRcdFx0XHQuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1vZHVsZXJjKVxuXHRcdFx0XTtcblx0XHRcdGlmICghc2NvcGVzLmxlbmd0aCkge1xuXHRcdFx0XHRzY29wZXMgPSBbQ29uZmlnU3RvcmUuZGVmYXVsdFNjb3BlXTtcblx0XHRcdH1cblx0XHRcdHNjb3Blcy5mb3JFYWNoKHNjb3BlID0+IHtcblx0XHRcdFx0bWVyZ2VkT3B0c1tzY29wZV0gPSB7IC4uLm1vZHVsZXJjW3Njb3BlXSwgLi4uaW5wdXRPcHRzW3Njb3BlXSwgc2NvcGUgfTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJvb3QgPSBQYXRoLm5vcm1hbGl6ZShtZXJnZWRPcHRzLnJvb3QpO1xuXHRcdGNvbnN0IG91dHB1dCA9IFBhdGgubm9ybWFsaXplKG1lcmdlZE9wdHMub3V0cHV0KTtcblx0XHRjb25zdCBlbnRyeSA9IFBhdGgubm9ybWFsaXplKG1lcmdlZE9wdHMuZW50cnkpO1xuXHRcdGNvbnN0IHJvb3REaXIgPSBQYXRoLnJlc29sdmUocm9vdCk7XG5cdFx0Y29uc3Qgb3V0cHV0RGlyID0gUGF0aC5yZXNvbHZlKG91dHB1dCk7XG5cdFx0Y29uc3QgZW50cnlEaXIgPSBDb25maWdTdG9yZS5nZXRFbnRyeURpcihyb290RGlyLCBlbnRyeSk7XG5cblx0XHRPYmplY3QuYXNzaWduKG1lcmdlZE9wdHMsIHsgcm9vdCwgb3V0cHV0LCBlbnRyeSwgcm9vdERpciwgb3V0cHV0RGlyLCBlbnRyeURpciB9KTtcblxuXHRcdC8vIEJhYmVsIGNvbmZpZ1xuXHRcdG1lcmdlZE9wdHMuYmFiZWwgPSBiYWJlbE1lcmdlLmFsbChtZXJnZVZhbHVlcy5tYXAoKHsgYmFiZWwgfSkgPT4gYmFiZWwpKTtcblxuXHRcdC8vIGluY2x1ZGUgZ2xvYnNcblx0XHRtZXJnZWRPcHRzLmluY2x1ZGUgPSBtZXJnZWRPcHRzLmluY2x1ZGUucmVkdWNlKChhY2MsIGluY2x1ZGUpID0+IHtcblx0XHRcdGlmIChnbG9iLmhhc01hZ2ljKGluY2x1ZGUpKSB7XG5cdFx0XHRcdGFjYy5wdXNoKFxuXHRcdFx0XHRcdC4uLmdsb2Jcblx0XHRcdFx0XHRcdC5zeW5jKGluY2x1ZGUsIHsgY3dkOiBtZXJnZWRPcHRzLnJvb3REaXIgfSlcblx0XHRcdFx0XHRcdC5tYXAocGF0aCA9PiBQYXRoLnJlc29sdmUobWVyZ2VkT3B0cy5yb290RGlyLCBwYXRoKSlcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFjYy5wdXNoKGluY2x1ZGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFjYztcblx0XHR9LCBbXSk7XG5cblx0XHQvLyBzZXJ2ZXIuc3RhdGljIGdsb2JzXG5cdFx0bWVyZ2VkT3B0cy5zZXJ2ZXIuc3RhdGljID0gbmV3IFNldChcblx0XHRcdEFycmF5LmZyb20obWVyZ2VkT3B0cy5zZXJ2ZXIuc3RhdGljKS5yZWR1Y2UoXG5cdFx0XHRcdChhY2MsIHBhdHRlcm4pID0+IFsuLi5hY2MsIC4uLihnbG9iLmhhc01hZ2ljKHBhdHRlcm4pID8gZ2xvYi5zeW5jKHBhdHRlcm4pIDogW3BhdHRlcm5dKV0sXG5cdFx0XHRcdFtdXG5cdFx0XHQpXG5cdFx0KTtcblxuXHRcdC8vIFJlbW92ZSBmYWxzeSBtaWRkbGV3YXJlIHZhbHVlc1xuXHRcdG1lcmdlZE9wdHMubWlkZGxld2FyZSA9IG1lcmdlZE9wdHMubWlkZGxld2FyZS5maWx0ZXIoQm9vbGVhbik7XG5cblx0XHQvLyBDYWxjdWxhdGVkIHByb3BlcnRpZXNcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihtZXJnZWRPcHRzLCBnZXRDYWxjdWxhdGVkKG1lcmdlZE9wdHMpKTtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKG9wdHMsIGNvbmZpZ1Jvb3QpIHtcblx0XHRDb25maWdTdG9yZS5nZXRFbnYuY2xlYXIoKTtcblxuXHRcdGRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdFx0ZGVmYXVsdHM6IGdldERlZmF1bHRzKCksXG5cdFx0XHRzY29wZUtleToge1xuXHRcdFx0XHRnZXQ6ICgpID0+IHRoaXMuc2NvcGUgJiYgQ29uZmlnU3RvcmUuc3ltYm9sT2YodGhpcy5zY29wZSksXG5cdFx0XHRcdHNldDogKCkgPT4ge30sXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChvcHRzKSB7XG5cdFx0XHRpZiAoY29uZmlnUm9vdCAmJiBvcHRzLnNjb3BlKSB7XG5cdFx0XHRcdHRoaXMuaW5pdFNjb3BlKG9wdHMsIGNvbmZpZ1Jvb3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5pbml0KG9wdHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGluaXQob3B0cykge1xuXHRcdE9iamVjdC5hc3NpZ24odGhpcywgQ29uZmlnU3RvcmUuZ2V0TWVyZ2VkT3B0cyhvcHRzKSk7XG5cdFx0dGhpcy5zY29wZXMoKS5mb3JFYWNoKHNjb3BlID0+IHtcblx0XHRcdE9iamVjdC5hc3NpZ24odGhpc1tzY29wZV0sIENvbmZpZ1N0b3JlLmdldE1lcmdlZE9wdHMob3B0cywgdGhpc1tzY29wZV0pKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGluaXRTY29wZShvcHRzLCBjb25maWdSb290KSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCBjbG9uZURlZXAob3B0cykpO1xuXHRcdHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgY29uZmlnUm9vdCB9KTtcblx0fVxuXG5cdHNjb3BlcygpIHtcblx0XHRyZXR1cm4gdGhpcy5zY29wZSA/IFt0aGlzLnNjb3BlXSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGhpcyk7XG5cdH1cblxuXHR1c2UoX3Njb3BlID0gQ29uZmlnU3RvcmUuZGVmYXVsdFNjb3BlKSB7XG5cdFx0Y29uc3Qgc2NvcGUgPSBDb25maWdTdG9yZS5zeW1ib2xGb3IoX3Njb3BlKTtcblx0XHRjb25zdCBzY29wZU9iamVjdCA9IHNjb3BlID09PSB0aGlzLnNjb3BlID8gdGhpcyA6IHRoaXNbc2NvcGVdO1xuXHRcdGlmICghc2NvcGVPYmplY3QpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgU2NvcGUgJyR7Q29uZmlnU3RvcmUuc3ltYm9sT2Yoc2NvcGUpfScgZG9lcyBub3QgZXhpc3RgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBDb25maWdTdG9yZShzY29wZU9iamVjdCwgdGhpcy5nZXRSb290KCkpO1xuXHR9XG5cblx0cnVuTWlkZGxld2FyZSh0eXBlLCBhcmdzKSB7XG5cdFx0Zm9yIChjb25zdCB7IGZuIH0gb2YgdGhpcy5taWRkbGV3YXJlLmZpbHRlcihtID0+IG0udHlwZSA9PT0gdHlwZSkpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG5cdFx0XHRmbi5hcHBseShudWxsLCBhcmdzKTtcblx0XHR9XG5cdH1cblxuXHRnZXRSb290KCkge1xuXHRcdHJldHVybiB0aGlzLmNvbmZpZ1Jvb3QgfHwgdGhpcztcblx0fVxuXG5cdGdldChwYXRoKSB7XG5cdFx0cmV0dXJuIGdldCh0aGlzLCBwYXRoKTtcblx0fVxuXG5cdHBpY2soa2V5cykge1xuXHRcdHJldHVybiBwaWNrKHRoaXMsIGtleXMpO1xuXHR9XG59XG4iXX0=