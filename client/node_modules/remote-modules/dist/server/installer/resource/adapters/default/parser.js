"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var babylon = _interopRequireWildcard(require("@babel/parser"));

var babel = _interopRequireWildcard(require("@babel/core"));

var _codeFrame = require("@babel/code-frame");

var _astq = _interopRequireDefault(require("astq"));

var _glob = _interopRequireDefault(require("glob"));

var _uglifyEs = _interopRequireDefault(require("uglify-es"));

var _cloneDeep = _interopRequireDefault(require("clone-deep"));

var _deepmerge = _interopRequireDefault(require("deepmerge"));

var _babelMerge = _interopRequireDefault(require("babel-merge"));

var _parser2 = _interopRequireDefault(require("../parser"));

var _resourceRequest = _interopRequireDefault(require("../../../generators/resource-request"));

var _memoize = _interopRequireDefault(require("../../../../../lib/helpers/memoize"));

var _pick = _interopRequireDefault(require("../../../../../lib/helpers/pick"));

var _helpers = require("../../../../../lib/helpers");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const astq = new _astq.default();
const excludeFromQuery = new Set(['start', 'end', 'computed']);
const buildQuery = (0, _memoize.default)(input => {
  let brackets;
  const node = typeof input === 'string' ? babylon.parseExpression(input) : input;
  return `${Object.entries(node).reduce((acc, [key, value]) => {
    switch (true) {
      case excludeFromQuery.has(key):
        // noop
        break;

      case key === 'type':
        // eslint-disable-next-line no-param-reassign
        acc = `${acc}${value}`;
        break;

      case Boolean(value && value.type):
        // nodes
        // eslint-disable-next-line no-param-reassign
        acc = `${acc} ${brackets ? '&&' : '['} /:${key} ${buildQuery(value)}`;
        brackets = true;
        break;

      case (0, _helpers.isPrimitive)(value):
        // primitive attributes
        // eslint-disable-next-line no-param-reassign
        acc = `${acc} ${brackets ? '&&' : '['} @${key} == ${typeof value === 'string' ? `'${value}'` : value}`;
        brackets = true;
        break;

      default:
        // noop
        break;
    }

    return acc;
  }, '')}${brackets ? ' ]' : ''}`;
});

function getBabelOpts(parser, resource, options) {
  const sourceMaps = Boolean(resource.options.sourceMaps);
  const retainLines = sourceMaps && resource.options.preset === 'node';
  return _babelMerge.default.all([_objectSpread({
    /**
     * IMPORTANT: babelrc is false so babel doesn't
     * attempt a babrlrc lookup on every transform
     */
    babelrc: false,
    filenameRelative: parser.sourceFilename,
    retainLines,
    sourceMaps,
    shouldPrintComment: content => parser.requests.some(({
      value
    }) => value === content)
  }, (0, _helpers.pickDefined)((0, _pick.default)(parser, ['filename', 'shouldPrintComment', 'sourceRoot']))), resource.isInstalledPackage() ? null : resource.getBabelOptions(), options]);
}

var _default = C => new _parser2.default({
  formatError(err) {
    const location = {
      start: err.loc,
      end: err.loc,
      filename: this.sourceFilename
    };
    const options = {
      message: err.message,
      highlightCode: true
    };
    const frame = (0, _codeFrame.codeFrameColumns)(this.source, location, options);
    return `${this.sourceFilename}:\n\n${frame}\n`;
  },

  parse(source, options) {
    return babylon.parse(source, _objectSpread({}, C.babylon, {
      sourceFilename: this.sourceFilename
    }, options));
  },

  buildQuery(input) {
    return buildQuery(input);
  },

  runQuery(query, ast = this.ast) {
    return astq.query(ast, query);
  },

  getRequests() {
    return Array.from([...this.runQuery(`
						// ImportDeclaration
					`), ...this.runQuery(`
						// CallExpression [
							/:callee ${buildQuery('require')}
						]
					`), ...this.runQuery(`
						// CallExpression [(
							/ ${buildQuery('System.import')}
						) || (
							/:callee Import
						)]
					`)].reduce((acc, node) => {
      const request = (0, _resourceRequest.default)(node, buildQuery);

      if (request.value && !acc.has(request.getKey())) {
        const key = request.getKey();
        acc.set(key, _objectSpread({}, request, {
          key
        }));
      } else if (request.pattern) {
        const cwd = _path.default.dirname(this.filename);

        _glob.default.sync(request.pattern, {
          cwd
        }).forEach(value => {
          const key = request.getKey(value);
          acc.set(key, _objectSpread({}, request, {
            key,
            value
          }));
        });
      }

      return acc;
    }, new Map()).values()).filter(request => request.value);
  },

  transform(resource, options) {
    const opts = getBabelOpts(this, resource, _objectSpread({}, options, {
      ast: true,
      code: false
    }));
    const {
      ast
    } = babel.transformFromAstSync(this.ast, null, opts);
    return ast;
  },

  generate(resource, options) {
    const opts = getBabelOpts(this, resource, options);
    const {
      code,
      map
    } = babel.transformFromAstSync(this.ast, this.source, opts);
    this.sourceMapJSON = _objectSpread({}, map, {
      sourcesContent: [this.source]
    });
    return `${code}${this.getSourceMappingURL(resource)}`;
  },

  compress(resource, options) {
    // FIXME: Uglify directly from AST before generate?
    // https://github.com/mishoo/UglifyJS2/tree/v3.3.12#using-native-uglify-ast-with-minify
    const opts = _deepmerge.default.all([resource.options.uglify, (0, _cloneDeep.default)(options)].filter(Boolean));

    const {
      code,
      error,
      map = '{}'
    } = _uglifyEs.default.minify({
      [this.resourceURL]: this.output
    }, opts);

    if (error) {
      throw error;
    }

    this.sourceMapJSON = _objectSpread({}, JSON.parse(map), {
      sourcesContent: [this.source]
    });
    return `${code}${this.getSourceMappingURL(resource)}`;
  }

});

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9zZXJ2ZXIvaW5zdGFsbGVyL3Jlc291cmNlL2FkYXB0ZXJzL2RlZmF1bHQvcGFyc2VyLmpzIl0sIm5hbWVzIjpbImFzdHEiLCJBU1RRIiwiZXhjbHVkZUZyb21RdWVyeSIsIlNldCIsImJ1aWxkUXVlcnkiLCJpbnB1dCIsImJyYWNrZXRzIiwibm9kZSIsImJhYnlsb24iLCJwYXJzZUV4cHJlc3Npb24iLCJPYmplY3QiLCJlbnRyaWVzIiwicmVkdWNlIiwiYWNjIiwia2V5IiwidmFsdWUiLCJoYXMiLCJCb29sZWFuIiwidHlwZSIsImdldEJhYmVsT3B0cyIsInBhcnNlciIsInJlc291cmNlIiwib3B0aW9ucyIsInNvdXJjZU1hcHMiLCJyZXRhaW5MaW5lcyIsInByZXNldCIsImJhYmVsTWVyZ2UiLCJhbGwiLCJiYWJlbHJjIiwiZmlsZW5hbWVSZWxhdGl2ZSIsInNvdXJjZUZpbGVuYW1lIiwic2hvdWxkUHJpbnRDb21tZW50IiwiY29udGVudCIsInJlcXVlc3RzIiwic29tZSIsImlzSW5zdGFsbGVkUGFja2FnZSIsImdldEJhYmVsT3B0aW9ucyIsIkMiLCJQYXJzZXIiLCJmb3JtYXRFcnJvciIsImVyciIsImxvY2F0aW9uIiwic3RhcnQiLCJsb2MiLCJlbmQiLCJmaWxlbmFtZSIsIm1lc3NhZ2UiLCJoaWdobGlnaHRDb2RlIiwiZnJhbWUiLCJzb3VyY2UiLCJwYXJzZSIsInJ1blF1ZXJ5IiwicXVlcnkiLCJhc3QiLCJnZXRSZXF1ZXN0cyIsIkFycmF5IiwiZnJvbSIsInJlcXVlc3QiLCJnZXRLZXkiLCJzZXQiLCJwYXR0ZXJuIiwiY3dkIiwiUGF0aCIsImRpcm5hbWUiLCJnbG9iIiwic3luYyIsImZvckVhY2giLCJNYXAiLCJ2YWx1ZXMiLCJmaWx0ZXIiLCJ0cmFuc2Zvcm0iLCJvcHRzIiwiY29kZSIsImJhYmVsIiwidHJhbnNmb3JtRnJvbUFzdFN5bmMiLCJnZW5lcmF0ZSIsIm1hcCIsInNvdXJjZU1hcEpTT04iLCJzb3VyY2VzQ29udGVudCIsImdldFNvdXJjZU1hcHBpbmdVUkwiLCJjb21wcmVzcyIsIm1lcmdlIiwidWdsaWZ5IiwiZXJyb3IiLCJVZ2xpZnlKUyIsIm1pbmlmeSIsInJlc291cmNlVVJMIiwib3V0cHV0IiwiSlNPTiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0FBRUEsTUFBTUEsSUFBSSxHQUFHLElBQUlDLGFBQUosRUFBYjtBQUVBLE1BQU1DLGdCQUFnQixHQUFHLElBQUlDLEdBQUosQ0FBUSxDQUFDLE9BQUQsRUFBVSxLQUFWLEVBQWlCLFVBQWpCLENBQVIsQ0FBekI7QUFFQSxNQUFNQyxVQUFVLEdBQUcsc0JBQVFDLEtBQUssSUFBSTtBQUNuQyxNQUFJQyxRQUFKO0FBQ0EsUUFBTUMsSUFBSSxHQUFHLE9BQU9GLEtBQVAsS0FBaUIsUUFBakIsR0FBNEJHLE9BQU8sQ0FBQ0MsZUFBUixDQUF3QkosS0FBeEIsQ0FBNUIsR0FBNkRBLEtBQTFFO0FBQ0EsU0FBUSxHQUFFSyxNQUFNLENBQUNDLE9BQVAsQ0FBZUosSUFBZixFQUFxQkssTUFBckIsQ0FBNEIsQ0FBQ0MsR0FBRCxFQUFNLENBQUNDLEdBQUQsRUFBTUMsS0FBTixDQUFOLEtBQXVCO0FBQzVELFlBQVEsSUFBUjtBQUNDLFdBQUtiLGdCQUFnQixDQUFDYyxHQUFqQixDQUFxQkYsR0FBckIsQ0FBTDtBQUNDO0FBQ0E7O0FBQ0QsV0FBS0EsR0FBRyxLQUFLLE1BQWI7QUFDQztBQUNBRCxRQUFBQSxHQUFHLEdBQUksR0FBRUEsR0FBSSxHQUFFRSxLQUFNLEVBQXJCO0FBQ0E7O0FBQ0QsV0FBS0UsT0FBTyxDQUFDRixLQUFLLElBQUlBLEtBQUssQ0FBQ0csSUFBaEIsQ0FBWjtBQUNDO0FBQ0E7QUFDQUwsUUFBQUEsR0FBRyxHQUFJLEdBQUVBLEdBQUksSUFBR1AsUUFBUSxHQUFH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QSxXQUFRLEdBQUV1QixJQUFLLEdBQUUsS0FBS08sbUJBQUwsQ0FBeUIxRCxRQUF6QixDQUFtQyxFQUFwRDtBQUNBLEdBeEVTOztBQXlFVjJELEVBQUFBLFFBQVEsQ0FBQzNELFFBQUQsRUFBV0MsT0FBWCxFQUFvQjtBQUMzQjtBQUNBO0FBQ0EsVUFBTWlELElBQUksR0FBR1UsbUJBQU10RCxHQUFOLENBQVUsQ0FBQ04sUUFBUSxDQUFDQyxPQUFULENBQWlCNEQsTUFBbEIsRUFBMEIsd0JBQVU1RCxPQUFWLENBQTFCLEVBQThDK0MsTUFBOUMsQ0FBcURwRCxPQUFyRCxDQUFWLENBQWI7O0FBQ0EsVUFBTTtBQUFFdUQsTUFBQUEsSUFBRjtBQUFRVyxNQUFBQSxLQUFSO0FBQWVQLE1BQUFBLEdBQUcsR0FBRztBQUFyQixRQUE4QlEsa0JBQVNDLE1BQVQsQ0FDbkM7QUFBRSxPQUFDLEtBQUtDLFdBQU4sR0FBb0IsS0FBS0M7QUFBM0IsS0FEbUMsRUFFbkNoQixJQUZtQyxDQUFwQzs7QUFJQSxRQUFJWSxLQUFKLEVBQVc7QUFDVixZQUFNQSxLQUFOO0FBQ0E7O0FBQ0QsU0FBS04sYUFBTCxxQkFBMEJXLElBQUksQ0FBQ3RDLEtBQUwsQ0FBVzBCLEdBQVgsQ0FBMUI7QUFBMkNFLE1BQUFBLGNBQWMsRUFBRSxDQUFDLEtBQUs3QixNQUFOO0FBQTNEO0FBQ0EsV0FBUSxHQUFFdUIsSUFBSyxHQUFFLEtBQUtPLG1CQUFMLENBQXlCMUQsUUFBekIsQ0FBbUMsRUFBcEQ7QUFDQTs7QUF0RlMsQ0FBWCxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCAqIGFzIGJhYnlsb24gZnJvbSAnQGJhYmVsL3BhcnNlcic7XG5pbXBvcnQgKiBhcyBiYWJlbCBmcm9tICdAYmFiZWwvY29yZSc7XG5pbXBvcnQgeyBjb2RlRnJhbWVDb2x1bW5zIH0gZnJvbSAnQGJhYmVsL2NvZGUtZnJhbWUnO1xuaW1wb3J0IEFTVFEgZnJvbSAnYXN0cSc7XG5pbXBvcnQgZ2xvYiBmcm9tICdnbG9iJztcbmltcG9ydCBVZ2xpZnlKUyBmcm9tICd1Z2xpZnktZXMnO1xuaW1wb3J0IGNsb25lRGVlcCBmcm9tICdjbG9uZS1kZWVwJztcbmltcG9ydCBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IGJhYmVsTWVyZ2UgZnJvbSAnYmFiZWwtbWVyZ2UnO1xuXG5pbXBvcnQgUGFyc2VyIGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQgZ2VuZXJhdGVSZXNvdXJjZVJlcXVlc3QgZnJvbSAnLi4vLi4vLi4vZ2VuZXJhdG9ycy9yZXNvdXJjZS1yZXF1ZXN0JztcbmltcG9ydCBtZW1vaXplIGZyb20gJy4uLy4uLy4uLy4uLy4uL2xpYi9oZWxwZXJzL21lbW9pemUnO1xuaW1wb3J0IHBpY2sgZnJvbSAnLi4vLi4vLi4vLi4vLi4vbGliL2hlbHBlcnMvcGljayc7XG5pbXBvcnQgeyBpc1ByaW1pdGl2ZSwgcGlja0RlZmluZWQgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9saWIvaGVscGVycyc7XG5cbmNvbnN0IGFzdHEgPSBuZXcgQVNUUSgpO1xuXG5jb25zdCBleGNsdWRlRnJvbVF1ZXJ5ID0gbmV3IFNldChbJ3N0YXJ0JywgJ2VuZCcsICdjb21wdXRlZCddKTtcblxuY29uc3QgYnVpbGRRdWVyeSA9IG1lbW9pemUoaW5wdXQgPT4ge1xuXHRsZXQgYnJhY2tldHM7XG5cdGNvbnN0IG5vZGUgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gYmFieWxvbi5wYXJzZUV4cHJlc3Npb24oaW5wdXQpIDogaW5wdXQ7XG5cdHJldHVybiBgJHtPYmplY3QuZW50cmllcyhub2RlKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG5cdFx0c3dpdGNoICh0cnVlKSB7XG5cdFx0XHRjYXNlIGV4Y2x1ZGVGcm9tUXVlcnkuaGFzKGtleSk6XG5cdFx0XHRcdC8vIG5vb3Bcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIGtleSA9PT0gJ3R5cGUnOlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0XHRcdFx0YWNjID0gYCR7YWNjfSR7dmFsdWV9YDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEJvb2xlYW4odmFsdWUgJiYgdmFsdWUudHlwZSk6XG5cdFx0XHRcdC8vIG5vZGVzXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdFx0XHRhY2MgPSBgJHthY2N9ICR7YnJhY2tldHMgPyAnJiYnIDogJ1snfSAvOiR7a2V5fSAke2J1aWxkUXVlcnkodmFsdWUpfWA7XG5cdFx0XHRcdGJyYWNrZXRzID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIGlzUHJpbWl0aXZlKHZhbHVlKTpcblx0XHRcdFx0Ly8gcHJpbWl0aXZlIGF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdFx0XHRcdGFjYyA9IGAke2FjY30gJHticmFja2V0cyA/ICcmJicgOiAnWyd9IEAke2tleX0gPT0gJHtcblx0XHRcdFx0XHR0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gYCcke3ZhbHVlfSdgIDogdmFsdWVcblx0XHRcdFx0fWA7XG5cdFx0XHRcdGJyYWNrZXRzID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHQvLyBub29wXG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRyZXR1cm4gYWNjO1xuXHR9LCAnJyl9JHticmFja2V0cyA/ICcgXScgOiAnJ31gO1xufSk7XG5cbmZ1bmN0aW9uIGdldEJhYmVsT3B0cyhwYXJzZXIsIHJlc291cmNlLCBvcHRpb25zKSB7XG5cdGNvbnN0IHNvdXJjZU1hcHMgPSBCb29sZWFuKHJlc291cmNlLm9wdGlvbnMuc291cmNlTWFwcyk7XG5cdGNvbnN0IHJldGFpbkxpbmVzID0gc291cmNlTWFwcyAmJiByZXNvdXJjZS5vcHRpb25zLnByZXNldCA9PT0gJ25vZGUnO1xuXHRyZXR1cm4gYmFiZWxNZXJnZS5hbGwoW1xuXHRcdHtcblx0XHRcdC8qKlxuXHRcdFx0ICogSU1QT1JUQU5UOiBiYWJlbHJjIGlzIGZhbHNlIHNvIGJhYmVsIGRvZXNuJ3Rcblx0XHRcdCAqIGF0dGVtcHQgYSBiYWJybHJjIGxvb2t1cCBvbiBldmVyeSB0cmFuc2Zvcm1cblx0XHRcdCAqL1xuXHRcdFx0YmFiZWxyYzogZmFsc2UsXG5cdFx0XHRmaWxlbmFtZVJlbGF0aXZlOiBwYXJzZXIuc291cmNlRmlsZW5hbWUsXG5cdFx0XHRyZXRhaW5MaW5lcyxcblx0XHRcdHNvdXJjZU1hcHMsXG5cdFx0XHRzaG91bGRQcmludENvbW1lbnQ6IGNvbnRlbnQgPT4gcGFyc2VyLnJlcXVlc3RzLnNvbWUoKHsgdmFsdWUgfSkgPT4gdmFsdWUgPT09IGNvbnRlbnQpLFxuXHRcdFx0Li4ucGlja0RlZmluZWQocGljayhwYXJzZXIsIFsnZmlsZW5hbWUnLCAnc2hvdWxkUHJpbnRDb21tZW50JywgJ3NvdXJjZVJvb3QnXSkpXG5cdFx0fSxcblx0XHRyZXNvdXJjZS5pc0luc3RhbGxlZFBhY2thZ2UoKSA/IG51bGwgOiByZXNvdXJjZS5nZXRCYWJlbE9wdGlvbnMoKSxcblx0XHRvcHRpb25zXG5cdF0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBDID0+XG5cdG5ldyBQYXJzZXIoe1xuXHRcdGZvcm1hdEVycm9yKGVycikge1xuXHRcdFx0Y29uc3QgbG9jYXRpb24gPSB7IHN0YXJ0OiBlcnIubG9jLCBlbmQ6IGVyci5sb2MsIGZpbGVuYW1lOiB0aGlzLnNvdXJjZUZpbGVuYW1lIH07XG5cdFx0XHRjb25zdCBvcHRpb25zID0geyBtZXNzYWdlOiBlcnIubWVzc2FnZSwgaGlnaGxpZ2h0Q29kZTogdHJ1ZSB9O1xuXHRcdFx0Y29uc3QgZnJhbWUgPSBjb2RlRnJhbWVDb2x1bW5zKHRoaXMuc291cmNlLCBsb2NhdGlvbiwgb3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gYCR7dGhpcy5zb3VyY2VGaWxlbmFtZX06XFxuXFxuJHtmcmFtZX1cXG5gO1xuXHRcdH0sXG5cdFx0cGFyc2Uoc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gYmFieWxvbi5wYXJzZShzb3VyY2UsIHtcblx0XHRcdFx0Li4uQy5iYWJ5bG9uLFxuXHRcdFx0XHRzb3VyY2VGaWxlbmFtZTogdGhpcy5zb3VyY2VGaWxlbmFtZSxcblx0XHRcdFx0Li4ub3B0aW9uc1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRidWlsZFF1ZXJ5KGlucHV0KSB7XG5cdFx0XHRyZXR1cm4gYnVpbGRRdWVyeShpbnB1dCk7XG5cdFx0fSxcblx0XHRydW5RdWVyeShxdWVyeSwgYXN0ID0gdGhpcy5hc3QpIHtcblx0XHRcdHJldHVybiBhc3RxLnF1ZXJ5KGFzdCwgcXVlcnkpO1xuXHRcdH0sXG5cdFx0Z2V0UmVxdWVzdHMoKSB7XG5cdFx0XHRyZXR1cm4gQXJyYXkuZnJvbShcblx0XHRcdFx0W1xuXHRcdFx0XHRcdC4uLnRoaXMucnVuUXVlcnkoXG5cdFx0XHRcdFx0XHRgXG5cdFx0XHRcdFx0XHQvLyBJbXBvcnREZWNsYXJhdGlvblxuXHRcdFx0XHRcdGBcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdC4uLnRoaXMucnVuUXVlcnkoXG5cdFx0XHRcdFx0XHRgXG5cdFx0XHRcdFx0XHQvLyBDYWxsRXhwcmVzc2lvbiBbXG5cdFx0XHRcdFx0XHRcdC86Y2FsbGVlICR7YnVpbGRRdWVyeSgncmVxdWlyZScpfVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdGBcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdC4uLnRoaXMucnVuUXVlcnkoXG5cdFx0XHRcdFx0XHRgXG5cdFx0XHRcdFx0XHQvLyBDYWxsRXhwcmVzc2lvbiBbKFxuXHRcdFx0XHRcdFx0XHQvICR7YnVpbGRRdWVyeSgnU3lzdGVtLmltcG9ydCcpfVxuXHRcdFx0XHRcdFx0KSB8fCAoXG5cdFx0XHRcdFx0XHRcdC86Y2FsbGVlIEltcG9ydFxuXHRcdFx0XHRcdFx0KV1cblx0XHRcdFx0XHRgXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRdXG5cdFx0XHRcdFx0LnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCByZXF1ZXN0ID0gZ2VuZXJhdGVSZXNvdXJjZVJlcXVlc3Qobm9kZSwgYnVpbGRRdWVyeSk7XG5cdFx0XHRcdFx0XHRpZiAocmVxdWVzdC52YWx1ZSAmJiAhYWNjLmhhcyhyZXF1ZXN0LmdldEtleSgpKSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBrZXkgPSByZXF1ZXN0LmdldEtleSgpO1xuXHRcdFx0XHRcdFx0XHRhY2Muc2V0KGtleSwgeyAuLi5yZXF1ZXN0LCBrZXkgfSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHJlcXVlc3QucGF0dGVybikge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBjd2QgPSBQYXRoLmRpcm5hbWUodGhpcy5maWxlbmFtZSk7XG5cdFx0XHRcdFx0XHRcdGdsb2Iuc3luYyhyZXF1ZXN0LnBhdHRlcm4sIHsgY3dkIH0pLmZvckVhY2godmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGtleSA9IHJlcXVlc3QuZ2V0S2V5KHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRhY2Muc2V0KGtleSwgeyAuLi5yZXF1ZXN0LCBrZXksIHZhbHVlIH0pO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBhY2M7XG5cdFx0XHRcdFx0fSwgbmV3IE1hcCgpKVxuXHRcdFx0XHRcdC52YWx1ZXMoKVxuXHRcdFx0KS5maWx0ZXIocmVxdWVzdCA9PiByZXF1ZXN0LnZhbHVlKTtcblx0XHR9LFxuXHRcdHRyYW5zZm9ybShyZXNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0Y29uc3Qgb3B0cyA9IGdldEJhYmVsT3B0cyh0aGlzLCByZXNvdXJjZSwgeyAuLi5vcHRpb25zLCBhc3Q6IHRydWUsIGNvZGU6IGZhbHNlIH0pO1xuXHRcdFx0Y29uc3QgeyBhc3QgfSA9IGJhYmVsLnRyYW5zZm9ybUZyb21Bc3RTeW5jKHRoaXMuYXN0LCBudWxsLCBvcHRzKTtcblx0XHRcdHJldHVybiBhc3Q7XG5cdFx0fSxcblx0XHRnZW5lcmF0ZShyZXNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0Y29uc3Qgb3B0cyA9IGdldEJhYmVsT3B0cyh0aGlzLCByZXNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHRjb25zdCB7IGNvZGUsIG1hcCB9ID0gYmFiZWwudHJhbnNmb3JtRnJvbUFzdFN5bmModGhpcy5hc3QsIHRoaXMuc291cmNlLCBvcHRzKTtcblx0XHRcdHRoaXMuc291cmNlTWFwSlNPTiA9IHsgLi4ubWFwLCBzb3VyY2VzQ29udGVudDogW3RoaXMuc291cmNlXSB9O1xuXHRcdFx0cmV0dXJuIGAke2NvZGV9JHt0aGlzLmdldFNvdXJjZU1hcHBpbmdVUkwocmVzb3VyY2UpfWA7XG5cdFx0fSxcblx0XHRjb21wcmVzcyhyZXNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0Ly8gRklYTUU6IFVnbGlmeSBkaXJlY3RseSBmcm9tIEFTVCBiZWZvcmUgZ2VuZXJhdGU/XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi90cmVlL3YzLjMuMTIjdXNpbmctbmF0aXZlLXVnbGlmeS1hc3Qtd2l0aC1taW5pZnlcblx0XHRcdGNvbnN0IG9wdHMgPSBtZXJnZS5hbGwoW3Jlc291cmNlLm9wdGlvbnMudWdsaWZ5LCBjbG9uZURlZXAob3B0aW9ucyldLmZpbHRlcihCb29sZWFuKSk7XG5cdFx0XHRjb25zdCB7IGNvZGUsIGVycm9yLCBtYXAgPSAne30nIH0gPSBVZ2xpZnlKUy5taW5pZnkoXG5cdFx0XHRcdHsgW3RoaXMucmVzb3VyY2VVUkxdOiB0aGlzLm91dHB1dCB9LFxuXHRcdFx0XHRvcHRzXG5cdFx0XHQpO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zb3VyY2VNYXBKU09OID0geyAuLi5KU09OLnBhcnNlKG1hcCksIHNvdXJjZXNDb250ZW50OiBbdGhpcy5zb3VyY2VdIH07XG5cdFx0XHRyZXR1cm4gYCR7Y29kZX0ke3RoaXMuZ2V0U291cmNlTWFwcGluZ1VSTChyZXNvdXJjZSl9YDtcblx0XHR9XG5cdH0pO1xuIl19